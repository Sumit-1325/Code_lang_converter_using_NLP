# coding: utf-8 (Token.Comment.Single)
import (Token.Keyword.Namespace)
re (Token.Name.Namespace)
import (Token.Keyword.Namespace)
math (Token.Name.Namespace)
from (Token.Keyword.Namespace)
collections (Token.Name.Namespace)
import (Token.Keyword.Namespace)
defaultdict (Token.Name)
import (Token.Keyword.Namespace)
itertools (Token.Name.Namespace)
from (Token.Keyword.Namespace)
copy (Token.Name.Namespace)
import (Token.Keyword.Namespace)
deepcopy (Token.Name)
import (Token.Keyword.Namespace)
random (Token.Name.Namespace)
from (Token.Keyword.Namespace)
heapq (Token.Name.Namespace)
import (Token.Keyword.Namespace)
heappop (Token.Name)
, (Token.Punctuation)
heappush (Token.Name)
import (Token.Keyword.Namespace)
time (Token.Name.Namespace)
import (Token.Keyword.Namespace)
os (Token.Name.Namespace)
import (Token.Keyword.Namespace)
queue (Token.Name.Namespace)
import (Token.Keyword.Namespace)
sys (Token.Name.Namespace)
import (Token.Keyword.Namespace)
datetime (Token.Name.Namespace)
from (Token.Keyword.Namespace)
functools (Token.Name.Namespace)
import (Token.Keyword.Namespace)
lru_cache (Token.Name)
#@lru_cache(maxsize=None) (Token.Comment.Single)
readline (Token.Name)
= (Token.Operator)
sys (Token.Name)
. (Token.Operator)
stdin (Token.Name)
. (Token.Operator)
readline (Token.Name)
sys (Token.Name)
. (Token.Operator)
setrecursionlimit (Token.Name)
( (Token.Punctuation)
2000000 (Token.Literal.Number.Integer)
) (Token.Punctuation)
#import numpy as np (Token.Comment.Single)
alphabet (Token.Name)
= (Token.Operator)
" (Token.Literal.String.Double)
abcdefghijklmnopqrstuvwxyz (Token.Literal.String.Double)
" (Token.Literal.String.Double)
mod (Token.Name)
= (Token.Operator)
int (Token.Name.Builtin)
( (Token.Punctuation)
10 (Token.Literal.Number.Integer)
* (Token.Operator)
* (Token.Operator)
9 (Token.Literal.Number.Integer)
+ (Token.Operator)
7 (Token.Literal.Number.Integer)
) (Token.Punctuation)
inf (Token.Name)
= (Token.Operator)
int (Token.Name.Builtin)
( (Token.Punctuation)
10 (Token.Literal.Number.Integer)
* (Token.Operator)
* (Token.Operator)
20 (Token.Literal.Number.Integer)
) (Token.Punctuation)
def (Token.Keyword)
yn (Token.Name.Function)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
b (Token.Name)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
yes (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
else (Token.Keyword)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
no (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
def (Token.Keyword)
Yn (Token.Name.Function)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
b (Token.Name)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
Yes (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
else (Token.Keyword)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
No (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
def (Token.Keyword)
YN (Token.Name.Function)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
b (Token.Name)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
YES (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
else (Token.Keyword)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
NO (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
class (Token.Keyword)
union_find (Token.Name.Class)
( (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
def (Token.Keyword)
__init__ (Token.Name.Function.Magic)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
n (Token.Name)
= (Token.Operator)
n (Token.Name)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
a (Token.Name)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
N (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
rank (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
n (Token.Name)
def (Token.Keyword)
find (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
!= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
def (Token.Keyword)
same (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
== (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
def (Token.Keyword)
link (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
rank (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
< (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
rank (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
y (Token.Name)
elif (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
rank (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
< (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
rank (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
x (Token.Name)
else (Token.Keyword)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
P (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
y (Token.Name)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
rank (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
+ (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
def (Token.Keyword)
unite (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
link (Token.Name)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
def (Token.Keyword)
size (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
) (Token.Punctuation)
: (Token.Punctuation)
S (Token.Name)
= (Token.Operator)
set (Token.Name.Builtin)
( (Token.Punctuation)
) (Token.Punctuation)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
n (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
S (Token.Name)
. (Token.Operator)
add (Token.Name)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
len (Token.Name.Builtin)
( (Token.Punctuation)
S (Token.Name)
) (Token.Punctuation)
def (Token.Keyword)
is_power (Token.Name.Function)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
#aはbの累乗数か (Token.Comment.Single)
now (Token.Name)
= (Token.Operator)
b (Token.Name)
while (Token.Keyword)
now (Token.Name)
< (Token.Operator)
a (Token.Name)
: (Token.Punctuation)
now (Token.Name)
* (Token.Operator)
= (Token.Operator)
b (Token.Name)
if (Token.Keyword)
now (Token.Name)
== (Token.Operator)
a (Token.Name)
: (Token.Punctuation)
return (Token.Keyword)
True (Token.Keyword.Constant)
else (Token.Keyword)
: (Token.Punctuation)
return (Token.Keyword)
False (Token.Keyword.Constant)
def (Token.Keyword)
bin_ (Token.Name.Function)
( (Token.Punctuation)
num (Token.Name)
, (Token.Punctuation)
size (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
A (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
size (Token.Name)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
size (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
num (Token.Name)
>> (Token.Operator)
( (Token.Punctuation)
size (Token.Name)
- (Token.Operator)
a (Token.Name)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
) (Token.Punctuation)
& (Token.Operator)
1 (Token.Literal.Number.Integer)
== (Token.Operator)
1 (Token.Literal.Number.Integer)
: (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
else (Token.Keyword)
: (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
return (Token.Keyword)
A (Token.Name)
def (Token.Keyword)
get_facs (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
mod_ (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
A (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
A (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
a (Token.Name)
if (Token.Keyword)
( (Token.Punctuation)
mod (Token.Name)
> (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
% (Token.Operator)
= (Token.Operator)
mod_ (Token.Name)
return (Token.Keyword)
A (Token.Name)
def (Token.Keyword)
comb (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
r (Token.Name)
, (Token.Punctuation)
mod (Token.Name)
, (Token.Punctuation)
fac (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
n (Token.Name)
- (Token.Operator)
r (Token.Name)
< (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
0 (Token.Literal.Number.Integer)
return (Token.Keyword)
( (Token.Punctuation)
fac (Token.Name)
[ (Token.Punctuation)
n (Token.Name)
] (Token.Punctuation)
* (Token.Operator)
pow (Token.Name.Builtin)
( (Token.Punctuation)
fac (Token.Name)
[ (Token.Punctuation)
n (Token.Name)
- (Token.Operator)
r (Token.Name)
] (Token.Punctuation)
, (Token.Punctuation)
mod (Token.Name)
- (Token.Operator)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
mod (Token.Name)
) (Token.Punctuation)
* (Token.Operator)
pow (Token.Name.Builtin)
( (Token.Punctuation)
fac (Token.Name)
[ (Token.Punctuation)
r (Token.Name)
] (Token.Punctuation)
, (Token.Punctuation)
mod (Token.Name)
- (Token.Operator)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
mod (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
% (Token.Operator)
mod (Token.Name)
def (Token.Keyword)
next_comb (Token.Name.Function)
( (Token.Punctuation)
num (Token.Name)
, (Token.Punctuation)
size (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
x (Token.Name)
= (Token.Operator)
num (Token.Name)
& (Token.Operator)
( (Token.Punctuation)
- (Token.Operator)
num (Token.Name)
) (Token.Punctuation)
y (Token.Name)
= (Token.Operator)
num (Token.Name)
+ (Token.Operator)
x (Token.Name)
z (Token.Name)
= (Token.Operator)
num (Token.Name)
& (Token.Operator)
( (Token.Punctuation)
~ (Token.Operator)
y (Token.Name)
) (Token.Punctuation)
z (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
= (Token.Operator)
x (Token.Name)
z (Token.Name)
= (Token.Operator)
z (Token.Name)
>> (Token.Operator)
1 (Token.Literal.Number.Integer)
num (Token.Name)
= (Token.Operator)
( (Token.Punctuation)
y (Token.Name)
| (Token.Operator)
z (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
num (Token.Name)
> (Token.Operator)
= (Token.Operator)
( (Token.Punctuation)
1 (Token.Literal.Number.Integer)
<< (Token.Operator)
size (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
False (Token.Keyword.Constant)
else (Token.Keyword)
: (Token.Punctuation)
return (Token.Keyword)
num (Token.Name)
def (Token.Keyword)
get_primes (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
type (Token.Name.Builtin)
= (Token.Operator)
" (Token.Literal.String.Double)
int (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
: (Token.Punctuation)
A (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
True (Token.Keyword.Constant)
] (Token.Punctuation)
* (Token.Operator)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
False (Token.Keyword.Constant)
A (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
False (Token.Keyword.Constant)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
: (Token.Punctuation)
for (Token.Keyword)
b (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
a (Token.Name)
* (Token.Operator)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
, (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
b (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
False (Token.Keyword.Constant)
if (Token.Keyword)
( (Token.Punctuation)
type (Token.Name.Builtin)
== (Token.Operator)
" (Token.Literal.String.Double)
bool (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
A (Token.Name)
B (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
] (Token.Punctuation)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
B (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
return (Token.Keyword)
B (Token.Name)
def (Token.Keyword)
is_prime (Token.Name.Function)
( (Token.Punctuation)
num (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
num (Token.Name)
< (Token.Operator)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
False (Token.Keyword.Constant)
i (Token.Name)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
while (Token.Keyword)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
num (Token.Name)
: (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
num (Token.Name)
% (Token.Operator)
i (Token.Name)
== (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
False (Token.Keyword.Constant)
i (Token.Name)
+ (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
return (Token.Keyword)
True (Token.Keyword.Constant)
def (Token.Keyword)
ifelse (Token.Name.Function)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
, (Token.Punctuation)
c (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
a (Token.Name)
: (Token.Punctuation)
return (Token.Keyword)
b (Token.Name)
else (Token.Keyword)
: (Token.Punctuation)
return (Token.Keyword)
c (Token.Name)
def (Token.Keyword)
join (Token.Name.Function)
( (Token.Punctuation)
A (Token.Name)
, (Token.Punctuation)
c (Token.Name)
= (Token.Operator)
" (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
: (Token.Punctuation)
n (Token.Name)
= (Token.Operator)
len (Token.Name.Builtin)
( (Token.Punctuation)
A (Token.Name)
) (Token.Punctuation)
A (Token.Name)
= (Token.Operator)
list (Token.Name.Builtin)
( (Token.Punctuation)
map (Token.Name.Builtin)
( (Token.Punctuation)
str (Token.Name.Builtin)
, (Token.Punctuation)
A (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
s (Token.Name)
= (Token.Operator)
" (Token.Literal.String.Double)
" (Token.Literal.String.Double)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
s (Token.Name)
+ (Token.Operator)
= (Token.Operator)
A (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
< (Token.Operator)
n (Token.Name)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
s (Token.Name)
+ (Token.Operator)
= (Token.Operator)
c (Token.Name)
return (Token.Keyword)
s (Token.Name)
def (Token.Keyword)
factorize (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
type_ (Token.Name)
= (Token.Operator)
" (Token.Literal.String.Double)
dict (Token.Literal.String.Double)
" (Token.Literal.String.Double)
) (Token.Punctuation)
: (Token.Punctuation)
b (Token.Name)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
list_ (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
] (Token.Punctuation)
while (Token.Keyword)
b (Token.Name)
* (Token.Operator)
b (Token.Name)
< (Token.Operator)
= (Token.Operator)
n (Token.Name)
: (Token.Punctuation)
while (Token.Keyword)
n (Token.Name)
% (Token.Operator)
b (Token.Name)
== (Token.Operator)
0 (Token.Literal.Number.Integer)
: (Token.Punctuation)
n (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
= (Token.Operator)
b (Token.Name)
list_ (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
b (Token.Name)
+ (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
if (Token.Keyword)
n (Token.Name)
> (Token.Operator)
1 (Token.Literal.Number.Integer)
: (Token.Punctuation)
list_ (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
type_ (Token.Name)
== (Token.Operator)
" (Token.Literal.String.Double)
dict (Token.Literal.String.Double)
" (Token.Literal.String.Double)
: (Token.Punctuation)
dic (Token.Name)
= (Token.Operator)
{ (Token.Punctuation)
} (Token.Punctuation)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
list_ (Token.Name)
: (Token.Punctuation)
if (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
dic (Token.Name)
: (Token.Punctuation)
dic (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
+ (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
else (Token.Keyword)
: (Token.Punctuation)
dic (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
return (Token.Keyword)
dic (Token.Name)
elif (Token.Keyword)
type_ (Token.Name)
== (Token.Operator)
" (Token.Literal.String.Double)
list (Token.Literal.String.Double)
" (Token.Literal.String.Double)
: (Token.Punctuation)
return (Token.Keyword)
list_ (Token.Name)
else (Token.Keyword)
: (Token.Punctuation)
return (Token.Keyword)
None (Token.Keyword.Constant)
def (Token.Keyword)
floor_ (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
x (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
x (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
n (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
def (Token.Keyword)
ceil_ (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
x (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
x (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
x (Token.Name)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
/ (Token.Operator)
/ (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
def (Token.Keyword)
hani (Token.Name.Function)
( (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
min_ (Token.Name)
, (Token.Punctuation)
max_ (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
ret (Token.Name)
= (Token.Operator)
x (Token.Name)
if (Token.Keyword)
x (Token.Name)
< (Token.Operator)
min_ (Token.Name)
: (Token.Punctuation)
ret (Token.Name)
= (Token.Operator)
min_ (Token.Name)
if (Token.Keyword)
x (Token.Name)
> (Token.Operator)
max_ (Token.Name)
: (Token.Punctuation)
ret (Token.Name)
= (Token.Operator)
max_ (Token.Name)
return (Token.Keyword)
ret (Token.Name)
def (Token.Keyword)
seifu (Token.Name.Function)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
x (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
abs (Token.Name.Builtin)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
################################################### (Token.Comment.Single)
def (Token.Keyword)
main (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
s (Token.Name)
= (Token.Operator)
input (Token.Name.Builtin)
( (Token.Punctuation)
) (Token.Punctuation)
ans (Token.Name)
= (Token.Operator)
" (Token.Literal.String.Double)
" (Token.Literal.String.Double)
for (Token.Keyword)
a (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
s (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
s (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
== (Token.Operator)
" (Token.Literal.String.Double)
B (Token.Literal.String.Double)
" (Token.Literal.String.Double)
: (Token.Punctuation)
ans (Token.Name)
= (Token.Operator)
ans (Token.Name)
[ (Token.Punctuation)
: (Token.Punctuation)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
else (Token.Keyword)
: (Token.Punctuation)
ans (Token.Name)
+ (Token.Operator)
= (Token.Operator)
s (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
ans (Token.Name)
) (Token.Punctuation)
main (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
