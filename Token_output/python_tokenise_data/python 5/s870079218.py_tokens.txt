import (Token.Keyword.Namespace)
sys (Token.Name.Namespace)
sys (Token.Name)
. (Token.Operator)
setrecursionlimit (Token.Name)
( (Token.Punctuation)
10 (Token.Literal.Number.Integer)
* (Token.Operator)
* (Token.Operator)
7 (Token.Literal.Number.Integer)
) (Token.Punctuation)
#再帰関数の上限,10**5以上の場合python (Token.Comment.Single)
import (Token.Keyword.Namespace)
math (Token.Name.Namespace)
from (Token.Keyword.Namespace)
copy (Token.Name.Namespace)
import (Token.Keyword.Namespace)
copy (Token.Name)
, (Token.Punctuation)
deepcopy (Token.Name)
from (Token.Keyword.Namespace)
copy (Token.Name.Namespace)
import (Token.Keyword.Namespace)
deepcopy (Token.Name)
as (Token.Keyword)
dcp (Token.Name)
from (Token.Keyword.Namespace)
operator (Token.Name.Namespace)
import (Token.Keyword.Namespace)
itemgetter (Token.Name)
from (Token.Keyword.Namespace)
bisect (Token.Name.Namespace)
import (Token.Keyword.Namespace)
bisect_left (Token.Name)
, (Token.Punctuation)
bisect (Token.Name)
, (Token.Punctuation)
bisect_right (Token.Name)
#2分探索 (Token.Comment.Single)
#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下 (Token.Comment.Single)
from (Token.Keyword.Namespace)
collections (Token.Name.Namespace)
import (Token.Keyword.Namespace)
deque (Token.Name)
, (Token.Punctuation)
defaultdict (Token.Name)
#deque(l), pop(), append(x), popleft(), appendleft(x) (Token.Comment.Single)
#q.rotate(n)で → にn回ローテート (Token.Comment.Single)
from (Token.Keyword.Namespace)
collections (Token.Name.Namespace)
import (Token.Keyword.Namespace)
Counter (Token.Name)
#文字列を個数カウント辞書に、 (Token.Comment.Single)
#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items() (Token.Comment.Single)
from (Token.Keyword.Namespace)
itertools (Token.Name.Namespace)
import (Token.Keyword.Namespace)
accumulate (Token.Name)
, (Token.Punctuation)
combinations (Token.Name)
, (Token.Punctuation)
permutations (Token.Name)
, (Token.Punctuation)
product (Token.Name)
#累積和 (Token.Comment.Single)
#list(accumulate(l)) (Token.Comment.Single)
from (Token.Keyword.Namespace)
heapq (Token.Name.Namespace)
import (Token.Keyword.Namespace)
heapify (Token.Name)
, (Token.Punctuation)
heappop (Token.Name)
, (Token.Punctuation)
heappush (Token.Name)
#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone (Token.Comment.Single)
#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする (Token.Comment.Single)
from (Token.Keyword.Namespace)
functools (Token.Name.Namespace)
import (Token.Keyword.Namespace)
reduce (Token.Name)
, (Token.Punctuation)
lru_cache (Token.Name)
#pypyでもうごく (Token.Comment.Single)
#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率 (Token.Comment.Single)
from (Token.Keyword.Namespace)
decimal (Token.Name.Namespace)
import (Token.Keyword.Namespace)
Decimal (Token.Name)
def (Token.Keyword)
input (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
x (Token.Name)
= (Token.Operator)
sys (Token.Name)
. (Token.Operator)
stdin (Token.Name)
. (Token.Operator)
readline (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
x (Token.Name)
[ (Token.Punctuation)
: (Token.Punctuation)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
if (Token.Keyword)
x (Token.Name)
[ (Token.Punctuation)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
== (Token.Operator)
" (Token.Literal.String.Double)
\n (Token.Literal.String.Escape)
" (Token.Literal.String.Double)
else (Token.Keyword)
x (Token.Name)
def (Token.Keyword)
printe (Token.Name.Function)
( (Token.Punctuation)
* (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
" (Token.Literal.String.Double)
##  (Token.Literal.String.Double)
" (Token.Literal.String.Double)
, (Token.Punctuation)
* (Token.Operator)
x (Token.Name)
, (Token.Punctuation)
file (Token.Name)
= (Token.Operator)
sys (Token.Name)
. (Token.Operator)
stderr (Token.Name)
) (Token.Punctuation)
def (Token.Keyword)
printl (Token.Name.Function)
( (Token.Punctuation)
li (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
_ (Token.Name)
= (Token.Operator)
print (Token.Name.Builtin)
( (Token.Punctuation)
* (Token.Operator)
li (Token.Name)
, (Token.Punctuation)
sep (Token.Name)
= (Token.Operator)
" (Token.Literal.String.Double)
\n (Token.Literal.String.Escape)
" (Token.Literal.String.Double)
) (Token.Punctuation)
if (Token.Keyword)
li (Token.Name)
else (Token.Keyword)
None (Token.Keyword.Constant)
def (Token.Keyword)
argsort (Token.Name.Function)
( (Token.Punctuation)
s (Token.Name)
, (Token.Punctuation)
return_sorted (Token.Name)
= (Token.Operator)
False (Token.Keyword.Constant)
) (Token.Punctuation)
: (Token.Punctuation)
inds (Token.Name)
= (Token.Operator)
sorted (Token.Name.Builtin)
( (Token.Punctuation)
range (Token.Name.Builtin)
( (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
s (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
, (Token.Punctuation)
key (Token.Name)
= (Token.Operator)
lambda (Token.Keyword)
k (Token.Name)
: (Token.Punctuation)
s (Token.Name)
[ (Token.Punctuation)
k (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
if (Token.Keyword)
return_sorted (Token.Name)
: (Token.Punctuation)
return (Token.Keyword)
inds (Token.Name)
, (Token.Punctuation)
[ (Token.Punctuation)
s (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
inds (Token.Name)
] (Token.Punctuation)
return (Token.Keyword)
inds (Token.Name)
def (Token.Keyword)
alp2num (Token.Name.Function)
( (Token.Punctuation)
c (Token.Name)
, (Token.Punctuation)
cap (Token.Name)
= (Token.Operator)
False (Token.Keyword.Constant)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
ord (Token.Name.Builtin)
( (Token.Punctuation)
c (Token.Name)
) (Token.Punctuation)
- (Token.Operator)
97 (Token.Literal.Number.Integer)
if (Token.Keyword)
not (Token.Operator.Word)
cap (Token.Name)
else (Token.Keyword)
ord (Token.Name.Builtin)
( (Token.Punctuation)
c (Token.Name)
) (Token.Punctuation)
- (Token.Operator)
65 (Token.Literal.Number.Integer)
def (Token.Keyword)
num2alp (Token.Name.Function)
( (Token.Punctuation)
i (Token.Name)
, (Token.Punctuation)
cap (Token.Name)
= (Token.Operator)
False (Token.Keyword.Constant)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
chr (Token.Name.Builtin)
( (Token.Punctuation)
i (Token.Name)
+ (Token.Operator)
97 (Token.Literal.Number.Integer)
) (Token.Punctuation)
if (Token.Keyword)
not (Token.Operator.Word)
cap (Token.Name)
else (Token.Keyword)
chr (Token.Name.Builtin)
( (Token.Punctuation)
i (Token.Name)
+ (Token.Operator)
65 (Token.Literal.Number.Integer)
) (Token.Punctuation)
def (Token.Keyword)
matmat (Token.Name.Function)
( (Token.Punctuation)
A (Token.Name)
, (Token.Punctuation)
B (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
K (Token.Name)
, (Token.Punctuation)
N (Token.Name)
, (Token.Punctuation)
M (Token.Name)
= (Token.Operator)
len (Token.Name.Builtin)
( (Token.Punctuation)
B (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
A (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
B (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
[ (Token.Punctuation)
[ (Token.Punctuation)
sum (Token.Name.Builtin)
( (Token.Punctuation)
[ (Token.Punctuation)
( (Token.Punctuation)
A (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
[ (Token.Punctuation)
k (Token.Name)
] (Token.Punctuation)
* (Token.Operator)
B (Token.Name)
[ (Token.Punctuation)
k (Token.Name)
] (Token.Punctuation)
[ (Token.Punctuation)
j (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
for (Token.Keyword)
k (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
K (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
) (Token.Punctuation)
for (Token.Keyword)
j (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
M (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
N (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
def (Token.Keyword)
matvec (Token.Name.Function)
( (Token.Punctuation)
M (Token.Name)
, (Token.Punctuation)
v (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
N (Token.Name)
, (Token.Punctuation)
size (Token.Name)
= (Token.Operator)
len (Token.Name.Builtin)
( (Token.Punctuation)
v (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
M (Token.Name)
) (Token.Punctuation)
return (Token.Keyword)
[ (Token.Punctuation)
sum (Token.Name.Builtin)
( (Token.Punctuation)
[ (Token.Punctuation)
M (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
[ (Token.Punctuation)
j (Token.Name)
] (Token.Punctuation)
* (Token.Operator)
v (Token.Name)
[ (Token.Punctuation)
j (Token.Name)
] (Token.Punctuation)
for (Token.Keyword)
j (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
N (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
) (Token.Punctuation)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
size (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
def (Token.Keyword)
T (Token.Name.Function)
( (Token.Punctuation)
M (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
m (Token.Name)
= (Token.Operator)
len (Token.Name.Builtin)
( (Token.Punctuation)
M (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
len (Token.Name.Builtin)
( (Token.Punctuation)
M (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
[ (Token.Punctuation)
[ (Token.Punctuation)
M (Token.Name)
[ (Token.Punctuation)
j (Token.Name)
] (Token.Punctuation)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
for (Token.Keyword)
j (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
m (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
def (Token.Keyword)
main (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
mod (Token.Name)
= (Token.Operator)
1000000007 (Token.Literal.Number.Integer)
#w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え (Token.Comment.Single)
#N = int(input()) (Token.Comment.Single)
W (Token.Name)
, (Token.Punctuation)
H (Token.Name)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
= (Token.Operator)
map (Token.Name.Builtin)
( (Token.Punctuation)
int (Token.Name.Builtin)
, (Token.Punctuation)
input (Token.Name.Builtin)
( (Token.Punctuation)
) (Token.Punctuation)
. (Token.Operator)
split (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
#A = tuple(map(int, input().split())) #1行ベクトル (Token.Comment.Single)
#L = tuple(int(input()) for i in range(N)) #改行ベクトル (Token.Comment.Single)
#S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列 (Token.Comment.Single)
half (Token.Name)
= (Token.Operator)
( (Token.Punctuation)
W (Token.Name)
* (Token.Operator)
H (Token.Name)
/ (Token.Operator)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
if (Token.Keyword)
W (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
2 (Token.Literal.Number.Integer)
== (Token.Operator)
x (Token.Name)
and (Token.Operator.Word)
H (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
2 (Token.Literal.Number.Integer)
== (Token.Operator)
y (Token.Name)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
half (Token.Name)
, (Token.Punctuation)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
else (Token.Keyword)
: (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
half (Token.Name)
, (Token.Punctuation)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
if (Token.Keyword)
__name__ (Token.Name.Variable.Magic)
== (Token.Operator)
" (Token.Literal.String.Double)
__main__ (Token.Literal.String.Double)
" (Token.Literal.String.Double)
: (Token.Punctuation)
main (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
