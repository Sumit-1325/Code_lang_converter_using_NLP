# input() (Token.Comment.Single)
# int(input()) (Token.Comment.Single)
# map(int, input().split()) (Token.Comment.Single)
# list(map(int, input().split())) (Token.Comment.Single)
# list(map(int, list(input()))) # スペースがない数字リストを読み込み (Token.Comment.Single)
import (Token.Keyword.Namespace)
math (Token.Name.Namespace)
import (Token.Keyword.Namespace)
fractions (Token.Name.Namespace)
import (Token.Keyword.Namespace)
sys (Token.Name.Namespace)
import (Token.Keyword.Namespace)
bisect (Token.Name.Namespace)
import (Token.Keyword.Namespace)
heapq (Token.Name.Namespace)
# 優先度付きキュー(最小値取り出し) (Token.Comment.Single)
import (Token.Keyword.Namespace)
collections (Token.Name.Namespace)
from (Token.Keyword.Namespace)
collections (Token.Name.Namespace)
import (Token.Keyword.Namespace)
Counter (Token.Name)
from (Token.Keyword.Namespace)
collections (Token.Name.Namespace)
import (Token.Keyword.Namespace)
deque (Token.Name)
import (Token.Keyword.Namespace)
pprint (Token.Name.Namespace)
import (Token.Keyword.Namespace)
itertools (Token.Name.Namespace)
sr (Token.Name)
= (Token.Operator)
lambda (Token.Keyword)
: (Token.Punctuation)
input (Token.Name.Builtin)
( (Token.Punctuation)
) (Token.Punctuation)
ir (Token.Name)
= (Token.Operator)
lambda (Token.Keyword)
: (Token.Punctuation)
int (Token.Name.Builtin)
( (Token.Punctuation)
sr (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
lr (Token.Name)
= (Token.Operator)
lambda (Token.Keyword)
: (Token.Punctuation)
list (Token.Name.Builtin)
( (Token.Punctuation)
map (Token.Name.Builtin)
( (Token.Punctuation)
int (Token.Name.Builtin)
, (Token.Punctuation)
sr (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
. (Token.Operator)
split (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
"""nを素因数分解""" (Token.Literal.String.Doc)
"""2以上の整数n => [[素因数, 指数], ...]の2次元リスト""" (Token.Literal.String.Doc)
def (Token.Keyword)
factorization (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
arr (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
] (Token.Punctuation)
temp (Token.Name)
= (Token.Operator)
n (Token.Name)
if (Token.Keyword)
n (Token.Name)
== (Token.Operator)
1 (Token.Literal.Number.Integer)
: (Token.Punctuation)
return (Token.Keyword)
arr (Token.Name)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
int (Token.Name.Builtin)
( (Token.Punctuation)
- (Token.Operator)
( (Token.Punctuation)
- (Token.Operator)
n (Token.Name)
* (Token.Operator)
* (Token.Operator)
0.5 (Token.Literal.Number.Float)
/ (Token.Operator)
/ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
) (Token.Punctuation)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
temp (Token.Name)
% (Token.Operator)
i (Token.Name)
== (Token.Operator)
0 (Token.Literal.Number.Integer)
: (Token.Punctuation)
cnt (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
while (Token.Keyword)
temp (Token.Name)
% (Token.Operator)
i (Token.Name)
== (Token.Operator)
0 (Token.Literal.Number.Integer)
: (Token.Punctuation)
cnt (Token.Name)
+ (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
temp (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
= (Token.Operator)
i (Token.Name)
arr (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
[ (Token.Punctuation)
i (Token.Name)
, (Token.Punctuation)
cnt (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
if (Token.Keyword)
temp (Token.Name)
!= (Token.Operator)
1 (Token.Literal.Number.Integer)
: (Token.Punctuation)
arr (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
[ (Token.Punctuation)
temp (Token.Name)
, (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
) (Token.Punctuation)
if (Token.Keyword)
arr (Token.Name)
== (Token.Operator)
[ (Token.Punctuation)
] (Token.Punctuation)
: (Token.Punctuation)
arr (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
[ (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
arr (Token.Name)
# a^n (Token.Comment.Single)
def (Token.Keyword)
power (Token.Name.Function)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
mod (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
x (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
while (Token.Keyword)
n (Token.Name)
: (Token.Punctuation)
if (Token.Keyword)
n (Token.Name)
& (Token.Operator)
1 (Token.Literal.Number.Integer)
: (Token.Punctuation)
x (Token.Name)
* (Token.Operator)
= (Token.Operator)
a (Token.Name)
% (Token.Operator)
mod (Token.Name)
n (Token.Name)
>> (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
a (Token.Name)
* (Token.Operator)
= (Token.Operator)
a (Token.Name)
% (Token.Operator)
mod (Token.Name)
return (Token.Keyword)
x (Token.Name)
% (Token.Operator)
mod (Token.Name)
# n*(n-1)*...*(l+1)*l (Token.Comment.Single)
def (Token.Keyword)
kaijo (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
l (Token.Name)
, (Token.Punctuation)
mod (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
n (Token.Name)
== (Token.Operator)
0 (Token.Literal.Number.Integer)
: (Token.Punctuation)
return (Token.Keyword)
1 (Token.Literal.Number.Integer)
a (Token.Name)
= (Token.Operator)
n (Token.Name)
tmp (Token.Name)
= (Token.Operator)
n (Token.Name)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
while (Token.Keyword)
( (Token.Punctuation)
tmp (Token.Name)
> (Token.Operator)
= (Token.Operator)
l (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
a (Token.Name)
= (Token.Operator)
a (Token.Name)
* (Token.Operator)
tmp (Token.Name)
% (Token.Operator)
mod (Token.Name)
tmp (Token.Name)
- (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
return (Token.Keyword)
a (Token.Name)
# Union Find (Token.Comment.Single)
class (Token.Keyword)
UnionFind (Token.Name.Class)
( (Token.Punctuation)
) (Token.Punctuation)
: (Token.Punctuation)
def (Token.Keyword)
__init__ (Token.Name.Function.Magic)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
n (Token.Name)
= (Token.Operator)
n (Token.Name)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
- (Token.Operator)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
n (Token.Name)
def (Token.Keyword)
find (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
< (Token.Operator)
0 (Token.Literal.Number.Integer)
: (Token.Punctuation)
return (Token.Keyword)
x (Token.Name)
else (Token.Keyword)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
def (Token.Keyword)
union (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
x (Token.Name)
= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
y (Token.Name)
= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
x (Token.Name)
== (Token.Operator)
y (Token.Name)
: (Token.Punctuation)
return (Token.Keyword)
if (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
> (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
: (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
= (Token.Operator)
y (Token.Name)
, (Token.Punctuation)
x (Token.Name)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
+ (Token.Operator)
= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
y (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
x (Token.Name)
def (Token.Keyword)
size (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
- (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
[ (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
def (Token.Keyword)
same (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
== (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
def (Token.Keyword)
members (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
, (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
root (Token.Name)
= (Token.Operator)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
return (Token.Keyword)
[ (Token.Punctuation)
i (Token.Name)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
n (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
i (Token.Name)
) (Token.Punctuation)
== (Token.Operator)
root (Token.Name)
] (Token.Punctuation)
def (Token.Keyword)
roots (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
[ (Token.Punctuation)
i (Token.Name)
for (Token.Keyword)
i (Token.Name)
, (Token.Punctuation)
x (Token.Name)
in (Token.Operator.Word)
enumerate (Token.Name.Builtin)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
parents (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
x (Token.Name)
< (Token.Operator)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
def (Token.Keyword)
group_count (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
len (Token.Name.Builtin)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
roots (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
def (Token.Keyword)
all_group_members (Token.Name.Function)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
{ (Token.Punctuation)
r (Token.Name)
: (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
members (Token.Name)
( (Token.Punctuation)
r (Token.Name)
) (Token.Punctuation)
for (Token.Keyword)
r (Token.Name)
in (Token.Operator.Word)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
roots (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
} (Token.Punctuation)
def (Token.Keyword)
__str__ (Token.Name.Function.Magic)
( (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
) (Token.Punctuation)
: (Token.Punctuation)
return (Token.Keyword)
' (Token.Literal.String.Single)
\n (Token.Literal.String.Escape)
' (Token.Literal.String.Single)
. (Token.Operator)
join (Token.Name)
( (Token.Punctuation)
' (Token.Literal.String.Single)
{} (Token.Literal.String.Interpol)
:  (Token.Literal.String.Single)
{} (Token.Literal.String.Interpol)
' (Token.Literal.String.Single)
. (Token.Operator)
format (Token.Name)
( (Token.Punctuation)
r (Token.Name)
, (Token.Punctuation)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
members (Token.Name)
( (Token.Punctuation)
r (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
for (Token.Keyword)
r (Token.Name)
in (Token.Operator.Word)
self (Token.Name.Builtin.Pseudo)
. (Token.Operator)
roots (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
# 約数生成 (Token.Comment.Single)
def (Token.Keyword)
make_divisors (Token.Name.Function)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
: (Token.Punctuation)
divisors (Token.Name)
= (Token.Operator)
[ (Token.Punctuation)
] (Token.Punctuation)
for (Token.Keyword)
i (Token.Name)
in (Token.Operator.Word)
range (Token.Name.Builtin)
( (Token.Punctuation)
1 (Token.Literal.Number.Integer)
, (Token.Punctuation)
int (Token.Name.Builtin)
( (Token.Punctuation)
n (Token.Name)
* (Token.Operator)
* (Token.Operator)
0.5 (Token.Literal.Number.Float)
) (Token.Punctuation)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
: (Token.Punctuation)
if (Token.Keyword)
n (Token.Name)
% (Token.Operator)
i (Token.Name)
== (Token.Operator)
0 (Token.Literal.Number.Integer)
: (Token.Punctuation)
divisors (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
i (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
i (Token.Name)
!= (Token.Operator)
n (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
i (Token.Name)
: (Token.Punctuation)
divisors (Token.Name)
. (Token.Operator)
append (Token.Name)
( (Token.Punctuation)
n (Token.Name)
/ (Token.Operator)
/ (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
divisors (Token.Name)
. (Token.Operator)
sort (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
return (Token.Keyword)
divisors (Token.Name)
inf (Token.Name)
= (Token.Operator)
10 (Token.Literal.Number.Integer)
* (Token.Operator)
* (Token.Operator)
18 (Token.Literal.Number.Integer)
mod (Token.Name)
= (Token.Operator)
10 (Token.Literal.Number.Integer)
* (Token.Operator)
* (Token.Operator)
9 (Token.Literal.Number.Integer)
+ (Token.Operator)
7 (Token.Literal.Number.Integer)
n (Token.Name)
= (Token.Operator)
ir (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
print (Token.Name.Builtin)
( (Token.Punctuation)
1110 (Token.Literal.Number.Integer)
- (Token.Operator)
n (Token.Name)
) (Token.Punctuation)
