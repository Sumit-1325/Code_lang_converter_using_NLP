//#include <bits/stdc++.h>
 (Token.Comment.Single)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<stdio.h> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<iostream> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<iomanip> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<cstdio> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<vector> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<map> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<unordered_map> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<set> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<tuple> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<string> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<algorithm> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<functional> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<queue> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<stack> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<cmath> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<bitset> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
using (Token.Keyword)
  (Token.Text.Whitespace)
namespace (Token.Keyword)
  (Token.Text.Whitespace)
std (Token.Name.Namespace)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
ll (Token.Name)
= (Token.Operator)
long (Token.Keyword.Type)
  (Token.Text.Whitespace)
long (Token.Keyword.Type)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
intpair (Token.Name)
= (Token.Operator)
pair (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
, (Token.Punctuation)
int (Token.Keyword.Type)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
intpv (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
intpair (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
llpair (Token.Name)
= (Token.Operator)
pair (Token.Name)
< (Token.Operator)
ll (Token.Name)
, (Token.Punctuation)
ll (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
llpv (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
llpair (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
intvec (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
llvec (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
intq (Token.Name)
= (Token.Operator)
queue (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
llq (Token.Name)
= (Token.Operator)
queue (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
intmat (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
intvec (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
llmat (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
llvec (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
pairmat (Token.Name)
= (Token.Operator)
vector (Token.Name)
< (Token.Operator)
llpv (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
# (Token.Comment.Preproc)
define matrix(T) vector<vector<T>> (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define PI 3.141592653589793 (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define INTINF 1<<30 (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define LLINF 1LL<<60 (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define MPRIME 1000000007 (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pqueue priority_queue (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pushb push_back (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define all(name) name.begin(),name.end() (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define rall(name) name.rbegin(),name.rend() (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define ABS(x) ( (x)>0 ? (x) : -(x) ) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define gsort(vbeg,vend) sort(vbeg,vend,greater<>()) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define init(v) for(auto &a_: v) cin>>a_ (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define out(n) cout<<n<<endl (Token.Comment.Preproc)

 (Token.Comment.Preproc)

 (Token.Text.Whitespace)
template (Token.Keyword)
< (Token.Operator)
class (Token.Keyword)
  (Token.Text.Whitespace)
T (Token.Name.Class)
> (Token.Operator)
  (Token.Text.Whitespace)
inline (Token.Keyword.Reserved)
  (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
chmin (Token.Name)
( (Token.Punctuation)
T (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
T (Token.Name)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
a (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
a (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
template (Token.Keyword)
< (Token.Operator)
class (Token.Keyword)
  (Token.Text.Whitespace)
T (Token.Name.Class)
> (Token.Operator)
  (Token.Text.Whitespace)
inline (Token.Keyword.Reserved)
  (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
chmax (Token.Name)
( (Token.Punctuation)
T (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
T (Token.Name)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
a (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
a (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
GCD (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//最大公約数
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
| (Token.Operator)
| (Token.Operator)
b (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
< (Token.Operator)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
swap (Token.Name)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
tmp (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
% (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
tmp (Token.Name)
! (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
a (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
b (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
tmp (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
tmp (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
% (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
binpow (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
ex (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//繰り返し二乗法
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
result (Token.Name)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
ex (Token.Name)
> (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
ex (Token.Name)
& (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
result (Token.Name)
= (Token.Operator)
result (Token.Name)
* (Token.Operator)
a (Token.Name)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ex (Token.Name)
> (Token.Operator)
> (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
a (Token.Name)
= (Token.Operator)
a (Token.Name)
* (Token.Operator)
a (Token.Name)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
Fact (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
x (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//階乗
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
f (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
x (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
f (Token.Name)
* (Token.Operator)
= (Token.Operator)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
f (Token.Name)
% (Token.Operator)
= (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
f (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
nPr (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
r (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
n (Token.Name)
< (Token.Operator)
r (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
result (Token.Name)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
r (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
result (Token.Name)
* (Token.Operator)
= (Token.Operator)
n (Token.Name)
- (Token.Operator)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
nPrP (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
r (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
// mod pにおけるnPr
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
n (Token.Name)
< (Token.Operator)
r (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
result (Token.Name)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
r (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
* (Token.Operator)
= (Token.Operator)
n (Token.Name)
- (Token.Operator)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
% (Token.Operator)
= (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
nCr (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
r (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
n (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
r (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
r (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
r (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
  (Token.Text.Whitespace)
/ (Token.Operator)
  (Token.Text.Whitespace)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
r (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
  (Token.Text.Whitespace)
- (Token.Operator)
  (Token.Text.Whitespace)
r (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
n (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
r (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
r (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
n (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
double (Token.Keyword.Type)
  (Token.Text.Whitespace)
result (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
double (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
r (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
  (Token.Text.Whitespace)
* (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
( (Token.Punctuation)
n (Token.Name)
  (Token.Text.Whitespace)
- (Token.Operator)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
+ (Token.Operator)
  (Token.Text.Whitespace)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
/ (Token.Operator)
  (Token.Text.Whitespace)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
ll (Token.Name)
) (Token.Punctuation)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
llvec (Token.Name)
  (Token.Text.Whitespace)
fact (Token.Name)
, (Token.Punctuation)
inv (Token.Name)
, (Token.Punctuation)
factinv (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
prenCrP (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
fact (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
inv (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
factinv (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
n (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
fact (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
fact (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
inv (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
factinv (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
factinv (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
2L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
n (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
fact (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
fact (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
-1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
i (Token.Name)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
inv (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
p (Token.Name)
- (Token.Operator)
inv (Token.Name)
[ (Token.Punctuation)
p (Token.Name)
% (Token.Operator)
i (Token.Name)
] (Token.Punctuation)
* (Token.Operator)
( (Token.Punctuation)
p (Token.Name)
/ (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
factinv (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
factinv (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
-1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
inv (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
nCrP (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
r (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
// mod pにおけるnCr
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
r (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
fact (Token.Name)
[ (Token.Punctuation)
n (Token.Name)
] (Token.Punctuation)
* (Token.Operator)
factinv (Token.Name)
[ (Token.Punctuation)
r (Token.Name)
] (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
* (Token.Operator)
factinv (Token.Name)
[ (Token.Punctuation)
n (Token.Name)
- (Token.Operator)
r (Token.Name)
] (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
llvec (Token.Name)
  (Token.Text.Whitespace)
fact2 (Token.Name)
, (Token.Punctuation)
inv2 (Token.Name)
, (Token.Punctuation)
factinv2 (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
prenCrP2 (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
r (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
// nがバカでかいときに使う, 計算量はr依存
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
fact2 (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
r (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
inv2 (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
r (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
factinv2 (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
r (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
fact2 (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
n (Token.Name)
% (Token.Operator)
p (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
fact2 (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
n (Token.Name)
% (Token.Operator)
p (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
n (Token.Name)
-1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
inv2 (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
factinv2 (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
factinv2 (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
2L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
r (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
fact2 (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
fact2 (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
-1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
( (Token.Punctuation)
n (Token.Name)
- (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
inv2 (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
p (Token.Name)
- (Token.Operator)
inv2 (Token.Name)
[ (Token.Punctuation)
p (Token.Name)
% (Token.Operator)
i (Token.Name)
] (Token.Punctuation)
* (Token.Operator)
( (Token.Punctuation)
p (Token.Name)
/ (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
factinv2 (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
factinv2 (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
-1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
inv2 (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
nCrP2 (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
r (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
p (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
fact2 (Token.Name)
[ (Token.Punctuation)
r (Token.Name)
-1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
* (Token.Operator)
factinv2 (Token.Name)
[ (Token.Punctuation)
r (Token.Name)
] (Token.Punctuation)
% (Token.Operator)
p (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
DigitNum (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//桁数
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
digit (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
wari (Token.Name)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
n (Token.Name)
/ (Token.Operator)
wari (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
digit (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
wari (Token.Name)
* (Token.Operator)
= (Token.Operator)
10 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
digit (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
IsPrime (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
num (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//素数判定
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
num (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
  (Token.Text.Whitespace)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
else (Token.Keyword)
  (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
num (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
else (Token.Keyword)
  (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
num (Token.Name)
  (Token.Text.Whitespace)
% (Token.Operator)
  (Token.Text.Whitespace)
2 (Token.Literal.Number.Integer)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)
  (Token.Text.Whitespace)
// 偶数はあらかじめ除く
 (Token.Comment.Single)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
double (Token.Keyword.Type)
  (Token.Text.Whitespace)
sqrtNum (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
sqrt (Token.Name)
( (Token.Punctuation)
num (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
3 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
sqrtNum (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
+ (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
num (Token.Name)
  (Token.Text.Whitespace)
% (Token.Operator)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
// 素数ではない
 (Token.Comment.Single)
			 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
// 素数である
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
Divisor (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
// 約数列挙
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
1L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
  (Token.Text.Whitespace)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
< (Token.Operator)
x (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
% (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
continue (Token.Keyword)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
i (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
x (Token.Name)
/ (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
= (Token.Operator)
= (Token.Operator)
x (Token.Name)
& (Token.Operator)
& (Token.Operator)
x (Token.Name)
% (Token.Operator)
i (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
i (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
sort (Token.Name)
( (Token.Punctuation)
result (Token.Name)
. (Token.Punctuation)
begin (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
, (Token.Punctuation)
result (Token.Name)
. (Token.Punctuation)
end (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
llpair (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
PrimeFact (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
// 素因数分解 {素因数,指数}
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
llpair (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
ex (Token.Name)
= (Token.Operator)
0L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
% (Token.Operator)
2 (Token.Literal.Number.Integer)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
% (Token.Operator)
2 (Token.Literal.Number.Integer)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
x (Token.Name)
/ (Token.Operator)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
ex (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
{ (Token.Punctuation)
2 (Token.Literal.Number.Integer)
, (Token.Punctuation)
ex (Token.Name)
} (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
3L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
x (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
% (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
continue (Token.Keyword)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ex (Token.Name)
= (Token.Operator)
0L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
% (Token.Operator)
i (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
x (Token.Name)
/ (Token.Operator)
= (Token.Operator)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
ex (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
result (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
{ (Token.Punctuation)
i (Token.Name)
, (Token.Punctuation)
ex (Token.Name)
} (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
x (Token.Name)
! (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
result (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
{ (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
1 (Token.Literal.Number.Integer)
} (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
result (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
Palind (Token.Name)
( (Token.Punctuation)
string (Token.Name)
  (Token.Text.Whitespace)
s (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//回文判定
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
s (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
string (Token.Name)
( (Token.Punctuation)
s (Token.Name)
. (Token.Punctuation)
rbegin (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
, (Token.Punctuation)
  (Token.Text.Whitespace)
s (Token.Name)
. (Token.Punctuation)
rend (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
struct (Token.Keyword)
  (Token.Text.Whitespace)
Union_Find (Token.Name.Class)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
  (Token.Text.Whitespace)
parent (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
//親
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
  (Token.Text.Whitespace)
num (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
//根としたときの木サイズ
 (Token.Comment.Single)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
Union_Find (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
N (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
: (Token.Operator)
  (Token.Text.Whitespace)
parent (Token.Name)
( (Token.Punctuation)
N (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
num (Token.Name)
( (Token.Punctuation)
N (Token.Name)
, (Token.Punctuation)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
N (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
parent (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
root (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
parent (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
= (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
x (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
parent (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
root (Token.Name)
( (Token.Punctuation)
parent (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
merge (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
x (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
y (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
xrt (Token.Name)
= (Token.Operator)
root (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
yrt (Token.Name)
= (Token.Operator)
root (Token.Name)
( (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
xrt (Token.Name)
= (Token.Operator)
= (Token.Operator)
yrt (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
parent (Token.Name)
[ (Token.Punctuation)
xrt (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
yrt (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
num (Token.Name)
[ (Token.Punctuation)
yrt (Token.Name)
] (Token.Punctuation)
+ (Token.Operator)
= (Token.Operator)
num (Token.Name)
[ (Token.Punctuation)
xrt (Token.Name)
] (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
same (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
x (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
y (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
root (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
= (Token.Operator)
= (Token.Operator)
root (Token.Name)
( (Token.Punctuation)
y (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
size (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
num (Token.Name)
[ (Token.Punctuation)
root (Token.Name)
( (Token.Punctuation)
x (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
struct (Token.Keyword)
  (Token.Text.Whitespace)
Ford_Fulkerson (Token.Name.Class)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
struct (Token.Keyword)
  (Token.Text.Whitespace)
_edge (Token.Name.Class)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
next (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
rev (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
// 逆辺の_edgeがG[next][rev]に存在する
 (Token.Comment.Single)
		 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
cap (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
vector (Token.Name)
< (Token.Operator)
_edge (Token.Name)
> (Token.Operator)
> (Token.Operator)
  (Token.Text.Whitespace)
G (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
bool (Token.Keyword.Type)
> (Token.Operator)
  (Token.Text.Whitespace)
used (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
Ford_Fulkerson (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
N (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
: (Token.Operator)
  (Token.Text.Whitespace)
G (Token.Name)
( (Token.Punctuation)
N (Token.Name)
) (Token.Punctuation)
, (Token.Punctuation)
used (Token.Name)
( (Token.Punctuation)
N (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
add_edge (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
from (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
to (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
cap (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
G (Token.Name)
[ (Token.Punctuation)
from (Token.Name)
] (Token.Punctuation)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
( (Token.Punctuation)
_edge (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)
to (Token.Name)
, (Token.Punctuation)
( (Token.Punctuation)
int (Token.Keyword.Type)
) (Token.Punctuation)
G (Token.Name)
[ (Token.Punctuation)
to (Token.Name)
] (Token.Punctuation)
. (Token.Punctuation)
size (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
, (Token.Punctuation)
cap (Token.Name)
} (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
G (Token.Name)
[ (Token.Punctuation)
to (Token.Name)
] (Token.Punctuation)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
( (Token.Punctuation)
_edge (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)
from (Token.Name)
, (Token.Punctuation)
( (Token.Punctuation)
int (Token.Keyword.Type)
) (Token.Punctuation)
G (Token.Name)
[ (Token.Punctuation)
from (Token.Name)
] (Token.Punctuation)
. (Token.Punctuation)
size (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
-1 (Token.Literal.Number.Integer)
, (Token.Punctuation)
0 (Token.Literal.Number.Integer)
} (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
f_dfs (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
s (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
t (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
flow (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
s (Token.Name)
= (Token.Operator)
= (Token.Operator)
t (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
flow (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
used (Token.Name)
[ (Token.Punctuation)
s (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
_edge (Token.Name)
  (Token.Text.Whitespace)
& (Token.Operator)
ed (Token.Name)
  (Token.Text.Whitespace)
: (Token.Operator)
  (Token.Text.Whitespace)
G (Token.Name)
[ (Token.Punctuation)
s (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
! (Token.Operator)
used (Token.Name)
[ (Token.Punctuation)
ed (Token.Name)
. (Token.Punctuation)
next (Token.Name)
] (Token.Punctuation)
  (Token.Text.Whitespace)
& (Token.Operator)
& (Token.Operator)
  (Token.Text.Whitespace)
ed (Token.Name)
. (Token.Punctuation)
cap (Token.Name)
> (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
				 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
captmp (Token.Name)
= (Token.Operator)
f_dfs (Token.Name)
( (Token.Punctuation)
ed (Token.Name)
. (Token.Punctuation)
next (Token.Name)
, (Token.Punctuation)
t (Token.Name)
, (Token.Punctuation)
min (Token.Name)
( (Token.Punctuation)
flow (Token.Name)
, (Token.Punctuation)
ed (Token.Name)
. (Token.Punctuation)
cap (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
				 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
captmp (Token.Name)
> (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
					 (Token.Text.Whitespace)
ed (Token.Name)
. (Token.Punctuation)
cap (Token.Name)
- (Token.Operator)
= (Token.Operator)
captmp (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
					 (Token.Text.Whitespace)
G (Token.Name)
[ (Token.Punctuation)
ed (Token.Name)
. (Token.Punctuation)
next (Token.Name)
] (Token.Punctuation)
[ (Token.Punctuation)
ed (Token.Name)
. (Token.Punctuation)
rev (Token.Name)
] (Token.Punctuation)
. (Token.Punctuation)
cap (Token.Name)
+ (Token.Operator)
= (Token.Operator)
captmp (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
					 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
captmp (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
				 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
0L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
max_flow (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
s (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
t (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
res (Token.Name)
= (Token.Operator)
0L (Token.Literal.Number.Float)
L (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
// 最大になるまで繰り返し
 (Token.Comment.Single)
			 (Token.Text.Whitespace)
used (Token.Name)
. (Token.Punctuation)
assign (Token.Name)
( (Token.Punctuation)
used (Token.Name)
. (Token.Punctuation)
size (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
, (Token.Punctuation)
false (Token.Name.Builtin)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
restmp (Token.Name)
= (Token.Operator)
f_dfs (Token.Name)
( (Token.Punctuation)
s (Token.Name)
, (Token.Punctuation)
t (Token.Name)
, (Token.Punctuation)
LLINF (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
restmp (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
res (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
res (Token.Name)
+ (Token.Operator)
= (Token.Operator)
restmp (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
struct (Token.Keyword)
  (Token.Text.Whitespace)
Vertex (Token.Name.Class)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
intvec (Token.Name)
  (Token.Text.Whitespace)
edge (Token.Name)
, (Token.Punctuation)
dist (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
string (Token.Name)
  (Token.Text.Whitespace)
S (Token.Name)
, (Token.Punctuation)
res (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
input (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cin (Token.Name)
> (Token.Operator)
> (Token.Operator)
S (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
solve (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
< (Token.Operator)
S (Token.Name)
. (Token.Punctuation)
length (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
S (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
= (Token.Operator)
' (Token.Literal.String.Char)
B (Token.Literal.String.Char)
' (Token.Literal.String.Char)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
! (Token.Operator)
res (Token.Name)
. (Token.Punctuation)
empty (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
  (Token.Text.Whitespace)
res (Token.Name)
. (Token.Punctuation)
pop_back (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
else (Token.Keyword)
  (Token.Text.Whitespace)
res (Token.Name)
. (Token.Punctuation)
pushb (Token.Name)
( (Token.Punctuation)
S (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
res (Token.Name)
< (Token.Operator)
< (Token.Operator)
endl (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
main (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
input (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
solve (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
break (Token.Keyword)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
