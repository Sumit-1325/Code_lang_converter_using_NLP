# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
<bits/stdc++.h> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
<ext/pb_ds/assoc_container.hpp> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
<ext/pb_ds/tree_policy.hpp> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
namespace (Token.Keyword)
  (Token.Text.Whitespace)
__gnu_pbds (Token.Name.Namespace)
; (Token.Punctuation)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
namespace (Token.Keyword)
  (Token.Text.Whitespace)
std (Token.Name.Namespace)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
template (Token.Keyword)
  (Token.Text.Whitespace)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
T (Token.Name.Class)
> (Token.Operator)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
ordered_set (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
tree (Token.Name)
< (Token.Operator)
T (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
null_type (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
less (Token.Name)
< (Token.Operator)
T (Token.Name)
> (Token.Operator)
, (Token.Punctuation)
  (Token.Text.Whitespace)
rb_tree_tag (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
tree_order_statistics_node_update (Token.Name)
> (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
# (Token.Comment.Preproc)
define all(a) a.begin(),a.end() (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define F first (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define S second (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pb push_back (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define ll long long (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define vi vector<int> (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pi pair<int,int> (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define mp make_pair (Token.Comment.Preproc)

 (Token.Comment.Preproc)
//~ #define int ll
 (Token.Comment.Single)
# (Token.Comment.Preproc)
ifdef LOCAL (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
"debug.h" (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
else (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define debug(...) "FUCK YOU" (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
endif (Token.Comment.Preproc)

 (Token.Comment.Preproc)

 (Token.Text.Whitespace)
const (Token.Keyword)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
mod (Token.Name)
= (Token.Operator)
1e9 (Token.Literal.Number.Float)
+ (Token.Operator)
7 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
mt19937 (Token.Name)
  (Token.Text.Whitespace)
rng (Token.Name.Function)
( (Token.Punctuation)
chrono (Token.Name)
: (Token.Operator)
: (Token.Operator)
steady_clock (Token.Name)
: (Token.Operator)
: (Token.Operator)
now (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
. (Token.Punctuation)
time_since_epoch (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
. (Token.Punctuation)
count (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
template (Token.Keyword)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
A (Token.Name.Class)
, (Token.Punctuation)
typename (Token.Keyword)
  (Token.Text.Whitespace)
B (Token.Name.Class)
> (Token.Operator)
  (Token.Text.Whitespace)
istream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
operator (Token.Keyword)
> (Token.Operator)
> (Token.Operator)
( (Token.Punctuation)
istream (Token.Name)
& (Token.Operator)
, (Token.Punctuation)
pair (Token.Name)
< (Token.Operator)
A (Token.Name)
, (Token.Punctuation)
B (Token.Name)
> (Token.Operator)
& (Token.Operator)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
template (Token.Keyword)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
A (Token.Name.Class)
> (Token.Operator)
  (Token.Text.Whitespace)
istream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
operator (Token.Keyword)
> (Token.Operator)
> (Token.Operator)
( (Token.Punctuation)
istream (Token.Name)
& (Token.Operator)
, (Token.Punctuation)
vector (Token.Name)
< (Token.Operator)
A (Token.Name)
> (Token.Operator)
& (Token.Operator)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
add (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
& (Token.Operator)
, (Token.Punctuation)
int (Token.Keyword.Type)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
mul (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
, (Token.Punctuation)
int (Token.Keyword.Type)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
powz (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
, (Token.Punctuation)
int (Token.Keyword.Type)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
template (Token.Keyword)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
A (Token.Name.Class)
> (Token.Operator)
  (Token.Text.Whitespace)
ostream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
operator (Token.Keyword)
< (Token.Operator)
< (Token.Operator)
( (Token.Punctuation)
ostream (Token.Name)
& (Token.Operator)
, (Token.Punctuation)
vector (Token.Name)
< (Token.Operator)
A (Token.Name)
> (Token.Operator)
& (Token.Operator)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
const (Token.Keyword)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
N (Token.Name)
= (Token.Operator)
500006 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
solve (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
w (Token.Name)
, (Token.Punctuation)
h (Token.Name)
, (Token.Punctuation)
x (Token.Name)
, (Token.Punctuation)
y (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cin (Token.Name)
> (Token.Operator)
> (Token.Operator)
w (Token.Name)
> (Token.Operator)
> (Token.Operator)
h (Token.Name)
> (Token.Operator)
> (Token.Operator)
x (Token.Name)
> (Token.Operator)
> (Token.Operator)
y (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
ans1 (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
, (Token.Punctuation)
ans2 (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
( (Token.Punctuation)
w (Token.Name)
- (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
< (Token.Operator)
= (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ans1 (Token.Name)
= (Token.Operator)
1l (Token.Literal.Number.Float)
l (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
w (Token.Name)
- (Token.Operator)
x (Token.Name)
) (Token.Punctuation)
* (Token.Operator)
h (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
else (Token.Keyword)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ans1 (Token.Name)
= (Token.Operator)
1l (Token.Literal.Number.Float)
l (Token.Name)
* (Token.Operator)
x (Token.Name)
* (Token.Operator)
h (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
( (Token.Punctuation)
h (Token.Name)
- (Token.Operator)
y (Token.Name)
) (Token.Punctuation)
< (Token.Operator)
= (Token.Operator)
y (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ans2 (Token.Name)
= (Token.Operator)
1l (Token.Literal.Number.Float)
l (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
h (Token.Name)
- (Token.Operator)
y (Token.Name)
) (Token.Punctuation)
* (Token.Operator)
w (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
else (Token.Keyword)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
ans2 (Token.Name)
= (Token.Operator)
1l (Token.Literal.Number.Float)
l (Token.Name)
* (Token.Operator)
y (Token.Name)
* (Token.Operator)
w (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
debug (Token.Name)
( (Token.Punctuation)
ans1 (Token.Name)
, (Token.Punctuation)
ans2 (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
ans1 (Token.Name)
= (Token.Operator)
= (Token.Operator)
ans2 (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
setprecision (Token.Name)
( (Token.Punctuation)
20 (Token.Literal.Number.Integer)
) (Token.Punctuation)
< (Token.Operator)
< (Token.Operator)
fixed (Token.Name)
< (Token.Operator)
< (Token.Operator)
ans1 (Token.Name)
< (Token.Operator)
< (Token.Operator)
" (Token.Literal.String)
 1 (Token.Literal.String)
" (Token.Literal.String)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
else (Token.Keyword)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
setprecision (Token.Name)
( (Token.Punctuation)
20 (Token.Literal.Number.Integer)
) (Token.Punctuation)
< (Token.Operator)
< (Token.Operator)
fixed (Token.Name)
< (Token.Operator)
< (Token.Operator)
max (Token.Name)
( (Token.Punctuation)
ans1 (Token.Name)
, (Token.Punctuation)
ans2 (Token.Name)
) (Token.Punctuation)
< (Token.Operator)
< (Token.Operator)
" (Token.Literal.String)
 0 (Token.Literal.String)
" (Token.Literal.String)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
			 (Token.Text.Whitespace)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
signed (Token.Keyword.Type)
  (Token.Text.Whitespace)
main (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
ios_base (Token.Name)
: (Token.Operator)
: (Token.Operator)
sync_with_stdio (Token.Name)
( (Token.Punctuation)
false (Token.Name.Builtin)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cin (Token.Name)
. (Token.Punctuation)
tie (Token.Name)
( (Token.Punctuation)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cout (Token.Name)
. (Token.Punctuation)
tie (Token.Name)
( (Token.Punctuation)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
tc (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
//~ cin>>tc;
 (Token.Comment.Single)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
_ (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
_ (Token.Name)
< (Token.Operator)
tc (Token.Name)
; (Token.Punctuation)
_ (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
//~ cout<<"Case #"<<_+1<<": ";
 (Token.Comment.Single)
		 (Token.Text.Whitespace)
solve (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
_ (Token.Name)
! (Token.Operator)
= (Token.Operator)
tc (Token.Name)
-1 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
" (Token.Literal.String)
\n (Token.Literal.String.Escape)
" (Token.Literal.String)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
mul (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
* (Token.Operator)
1l (Token.Literal.Number.Float)
l (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
% (Token.Operator)
mod (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
add (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
& (Token.Operator)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
a (Token.Name)
+ (Token.Operator)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
> (Token.Operator)
= (Token.Operator)
mod (Token.Name)
) (Token.Punctuation)
a (Token.Name)
- (Token.Operator)
= (Token.Operator)
mod (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
< (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
a (Token.Name)
+ (Token.Operator)
= (Token.Operator)
mod (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
powz (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
res (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
b (Token.Name)
& (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
res (Token.Name)
= (Token.Operator)
mul (Token.Name)
( (Token.Punctuation)
res (Token.Name)
, (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
b (Token.Name)
/ (Token.Operator)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
a (Token.Name)
= (Token.Operator)
mul (Token.Name)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
res (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
template (Token.Keyword)
  (Token.Text.Whitespace)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
A (Token.Name.Class)
, (Token.Punctuation)
  (Token.Text.Whitespace)
typename (Token.Keyword)
  (Token.Text.Whitespace)
B (Token.Name.Class)
> (Token.Operator)

 (Token.Text.Whitespace)
istream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
operator (Token.Keyword)
> (Token.Operator)
> (Token.Operator)
( (Token.Punctuation)
istream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
input (Token.Name)
, (Token.Punctuation)
pair (Token.Name)
< (Token.Operator)
A (Token.Name)
, (Token.Punctuation)
B (Token.Name)
> (Token.Operator)
& (Token.Operator)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
input (Token.Name)
> (Token.Operator)
> (Token.Operator)
x (Token.Name)
. (Token.Punctuation)
F (Token.Name)
> (Token.Operator)
> (Token.Operator)
x (Token.Name)
. (Token.Punctuation)
S (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
input (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
template (Token.Keyword)
  (Token.Text.Whitespace)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
A (Token.Name.Class)
> (Token.Operator)

 (Token.Text.Whitespace)
istream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
operator (Token.Keyword)
> (Token.Operator)
> (Token.Operator)
( (Token.Punctuation)
istream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
input (Token.Name)
, (Token.Punctuation)
vector (Token.Name)
< (Token.Operator)
A (Token.Name)
> (Token.Operator)
& (Token.Operator)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
auto (Token.Keyword)
& (Token.Operator)
  (Token.Text.Whitespace)
i (Token.Name)
: (Token.Operator)
x (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
		 (Token.Text.Whitespace)
input (Token.Name)
> (Token.Operator)
> (Token.Operator)
i (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
input (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
template (Token.Keyword)
< (Token.Operator)
typename (Token.Keyword)
  (Token.Text.Whitespace)
A (Token.Name.Class)
> (Token.Operator)

 (Token.Text.Whitespace)
ostream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
operator (Token.Keyword)
< (Token.Operator)
< (Token.Operator)
( (Token.Punctuation)
ostream (Token.Name)
& (Token.Operator)
  (Token.Text.Whitespace)
output (Token.Name)
, (Token.Punctuation)
vector (Token.Name)
< (Token.Operator)
A (Token.Name)
> (Token.Operator)
& (Token.Operator)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
auto (Token.Keyword)
& (Token.Operator)
  (Token.Text.Whitespace)
i (Token.Name)
: (Token.Operator)
x (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
	     (Token.Text.Whitespace)
output (Token.Name)
< (Token.Operator)
< (Token.Operator)
i (Token.Name)
< (Token.Operator)
< (Token.Operator)
' (Token.Literal.String.Char)
  (Token.Literal.String.Char)
' (Token.Literal.String.Char)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
output (Token.Name)
; (Token.Punctuation)
	 (Token.Text.Whitespace)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
