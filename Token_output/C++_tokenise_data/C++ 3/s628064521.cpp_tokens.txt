# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
  (Token.Text.Whitespace)
<bits/stdc++.h> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
// Hey! 僕の提出を見てくれてありがとう.
 (Token.Comment.Single)
// ロボ子さん可愛いぞ！！！！！君もV沼にはまろう↓
 (Token.Comment.Single)
// https://www.youtube.com/channel/UCDqI2jOz0weumE8s7paEk6g
 (Token.Comment.Single)
using (Token.Keyword)
  (Token.Text.Whitespace)
namespace (Token.Keyword)
  (Token.Text.Whitespace)
std (Token.Name.Namespace)
; (Token.Punctuation)

 (Token.Text.Whitespace)
/*
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
namespace mp = boost::multiprecision;// 任意長整数型
using bint = mp::cpp_int;// 仮数部長が32の浮動小数点数型
using real32 = mp::number<mp::cpp_dec_float<32>>;// 仮数部長が1024の浮動小数点数型
using real1024 = mp::number<mp::cpp_dec_float<1024>>;// ついでに有理数型
using rat = boost::rational<bint>;
*/ (Token.Comment.Multiline)

 (Token.Text.Whitespace)
using (Token.Keyword)
  (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
long (Token.Keyword.Type)
  (Token.Text.Whitespace)
long (Token.Keyword.Type)
; (Token.Punctuation)

 (Token.Text.Whitespace)
ll (Token.Name)
  (Token.Text.Whitespace)
gcd (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)
return (Token.Keyword)
  (Token.Text.Whitespace)
b (Token.Name)
? (Token.Operator)
gcd (Token.Name)
( (Token.Punctuation)
b (Token.Name)
, (Token.Punctuation)
a (Token.Name)
% (Token.Operator)
b (Token.Name)
) (Token.Punctuation)
: (Token.Operator)
a (Token.Name)
; (Token.Punctuation)
} (Token.Punctuation)
//a,bの最大公約数(gcd)を求める
 (Token.Comment.Single)
ll (Token.Name)
  (Token.Text.Whitespace)
lcm (Token.Name.Function)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)
return (Token.Keyword)
  (Token.Text.Whitespace)
abs (Token.Name)
( (Token.Punctuation)
a (Token.Name)
* (Token.Operator)
b (Token.Name)
) (Token.Punctuation)
/ (Token.Operator)
gcd (Token.Name)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)
} (Token.Punctuation)
//a,bの最小公倍数(lcm)を求める
 (Token.Comment.Single)
vector (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
enum_div (Token.Name)
( (Token.Punctuation)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)
vector (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
ret (Token.Name)
; (Token.Punctuation)
for (Token.Keyword)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
  (Token.Text.Whitespace)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
n (Token.Name)
  (Token.Text.Whitespace)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
{ (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
n (Token.Name)
% (Token.Operator)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
{ (Token.Punctuation)
ret (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
i (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
i (Token.Name)
! (Token.Operator)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
  (Token.Text.Whitespace)
& (Token.Operator)
& (Token.Operator)
  (Token.Text.Whitespace)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
! (Token.Operator)
= (Token.Operator)
n (Token.Name)
) (Token.Punctuation)
ret (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
n (Token.Name)
/ (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)
} (Token.Punctuation)
} (Token.Punctuation)
ret (Token.Name)
. (Token.Punctuation)
push_back (Token.Name)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)
return (Token.Keyword)
  (Token.Text.Whitespace)
ret (Token.Name)
; (Token.Punctuation)
} (Token.Punctuation)

 (Token.Text.Whitespace)
//↑nの約数を求める
 (Token.Comment.Single)
vector (Token.Name)
< (Token.Operator)
bool (Token.Keyword.Type)
> (Token.Operator)
  (Token.Text.Whitespace)
IsPrime (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
sieve (Token.Name.Function)
( (Token.Punctuation)
size_t (Token.Keyword.Type)
  (Token.Text.Whitespace)
max (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
max (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
  (Token.Text.Whitespace)
> (Token.Operator)
  (Token.Text.Whitespace)
IsPrime (Token.Name)
. (Token.Punctuation)
size (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
) (Token.Punctuation)
IsPrime (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
max (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
, (Token.Punctuation)
true (Token.Name.Builtin)
) (Token.Punctuation)
; (Token.Punctuation)
IsPrime (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)
IsPrime (Token.Name)
[ (Token.Punctuation)
1 (Token.Literal.Number.Integer)
] (Token.Punctuation)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)
for (Token.Keyword)
( (Token.Punctuation)
size_t (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
* (Token.Operator)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
max (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
+ (Token.Operator)
+ (Token.Operator)
i (Token.Name)
) (Token.Punctuation)
if (Token.Keyword)
( (Token.Punctuation)
IsPrime (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
for (Token.Keyword)
( (Token.Punctuation)
size_t (Token.Keyword.Type)
  (Token.Text.Whitespace)
j (Token.Name)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
* (Token.Operator)
j (Token.Name)
< (Token.Operator)
= (Token.Operator)
max (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
+ (Token.Operator)
+ (Token.Operator)
j (Token.Name)
) (Token.Punctuation)
IsPrime (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
* (Token.Operator)
j (Token.Name)
] (Token.Punctuation)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)
} (Token.Punctuation)

 (Token.Text.Whitespace)
//↑エラトステネスの篩で素数を求める
 (Token.Comment.Single)
# (Token.Comment.Preproc)
define roundup(divisor,dividend) (divisor + (dividend - 1))  (Token.Comment.Preproc)
/ (Token.Comment.Preproc)
 dividend  (Token.Comment.Preproc)
//切り上げ割り算
 (Token.Comment.Single)
# (Token.Comment.Preproc)
define all(x) (x).begin(),(x).end()  (Token.Comment.Preproc)
//xの初めから終わりまでのポインタ
 (Token.Comment.Single)
# (Token.Comment.Preproc)
define size_t ll  (Token.Comment.Preproc)
//size_tは自動でllに変換される
 (Token.Comment.Single)
# (Token.Comment.Preproc)
define pb(x) push_back(x) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pri_queue priority_queue  (Token.Comment.Preproc)
//優先度付きキュー
 (Token.Comment.Single)
# (Token.Comment.Preproc)
define syo(x) fixed << setprecision(x)  (Token.Comment.Preproc)
//iostreamで小数をx桁表示
 (Token.Comment.Single)
//sortを降順にする時は greater<型>()
 (Token.Comment.Single)
ll (Token.Name)
  (Token.Text.Whitespace)
n (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
ll (Token.Name)
> (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
main (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
{ (Token.Punctuation)
  (Token.Text.Whitespace)
//srand((unsigned)time(NULL));
 (Token.Comment.Single)
   (Token.Text.Whitespace)
cin (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
> (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
a (Token.Name)
. (Token.Punctuation)
resize (Token.Name)
( (Token.Punctuation)
n (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
for (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
+ (Token.Operator)
+ (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
cin (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
> (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
for (Token.Keyword)
  (Token.Text.Whitespace)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
  (Token.Text.Whitespace)
n (Token.Name)
-1 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
  (Token.Text.Whitespace)
> (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)
  (Token.Text.Whitespace)
i (Token.Name)
- (Token.Operator)
- (Token.Operator)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
cout (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
< (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
  (Token.Text.Whitespace)
< (Token.Operator)
< (Token.Operator)
  (Token.Text.Whitespace)
( (Token.Punctuation)
i (Token.Name)
  (Token.Text.Whitespace)
= (Token.Operator)
= (Token.Operator)
  (Token.Text.Whitespace)
0 (Token.Literal.Number.Integer)
  (Token.Text.Whitespace)
? (Token.Operator)
  (Token.Text.Whitespace)
" (Token.Literal.String)
" (Token.Literal.String)
: (Token.Operator)
" (Token.Literal.String)
  (Token.Literal.String)
" (Token.Literal.String)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
cout (Token.Name)
  (Token.Text.Whitespace)
< (Token.Operator)
< (Token.Operator)
  (Token.Text.Whitespace)
endl (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
