# (Token.Comment.Preproc)
include (Token.Comment.Preproc)
<bits/stdc++.h> (Token.Comment.PreprocFile)

 (Token.Comment.Preproc)
using (Token.Keyword)
  (Token.Text.Whitespace)
namespace (Token.Keyword)
  (Token.Text.Whitespace)
std (Token.Name.Namespace)
; (Token.Punctuation)

 (Token.Text.Whitespace)
//#define int long long
 (Token.Comment.Single)
# (Token.Comment.Preproc)
define fo(a,b) for(int a=0;a<b;a++) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define Sort(a) sort(a.begin(),a.end()) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define rev(a) reverse(a.begin(),a.end()) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define fi first (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define se second (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define co(a) cout<<a<<endl (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define sz size() (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define bgn begin() (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define en end() (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pb(a) push_back(a) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define pop pop_back (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define V vector (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define P pair (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define V2(a,b,c) V<V<int>> a(b,V<int>(c)) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define V2a(a,b,c,d) V<V<int>> a(b,V<int>(c,d)) (Token.Comment.Preproc)

 (Token.Comment.Preproc)
# (Token.Comment.Preproc)
define incin(a) int a; cin>>a (Token.Comment.Preproc)

 (Token.Comment.Preproc)
//#define min min<int>
 (Token.Comment.Single)
//#define max max<int>
 (Token.Comment.Single)
template (Token.Keyword)
< (Token.Operator)
class (Token.Keyword)
  (Token.Text.Whitespace)
T (Token.Name.Class)
> (Token.Operator)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
cou (Token.Name)
( (Token.Punctuation)
vector (Token.Name)
< (Token.Operator)
vector (Token.Name)
< (Token.Operator)
T (Token.Name)
> (Token.Operator)
> (Token.Operator)
  (Token.Text.Whitespace)
a (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
a (Token.Name)
. (Token.Punctuation)
size (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
c (Token.Name)
= (Token.Operator)
a (Token.Name)
[ (Token.Punctuation)
0 (Token.Literal.Number.Integer)
] (Token.Punctuation)
. (Token.Punctuation)
size (Token.Name)
( (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
fo (Token.Name)
( (Token.Punctuation)
i (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
fo (Token.Name)
( (Token.Punctuation)
j (Token.Name)
, (Token.Punctuation)
c (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
a (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
[ (Token.Punctuation)
j (Token.Name)
] (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
j (Token.Name)
= (Token.Operator)
= (Token.Operator)
c (Token.Name)
-1 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
         (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
endl (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
else (Token.Keyword)

 (Token.Text.Whitespace)
         (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
' (Token.Literal.String.Char)
  (Token.Literal.String.Char)
' (Token.Literal.String.Char)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
/*template<>
 void cou(vector<vector<char>> a){
  int b=a.size();
  int c=a[0].size();
  fo(i,b){
    fo(j,c){
      cout<<a[i][j];
      if(j==c-1)
        cout<<endl;
      else
        cout<<' ';
    }
  }
}*/ (Token.Comment.Multiline)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
wari (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
  (Token.Text.Whitespace)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
% (Token.Operator)
b (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
      (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
a (Token.Name)
/ (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
else (Token.Keyword)

 (Token.Text.Whitespace)
      (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
a (Token.Name)
/ (Token.Operator)
b (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
keta (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
double (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
a (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
log10 (Token.Name)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
c (Token.Name)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
c (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
souwa (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
a (Token.Name)
* (Token.Operator)
( (Token.Punctuation)
a (Token.Name)
+ (Token.Operator)
1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
/ (Token.Operator)
2 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
lcm (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
d (Token.Name)
= (Token.Operator)
a (Token.Name)
, (Token.Punctuation)
e (Token.Name)
= (Token.Operator)
b (Token.Name)
, (Token.Punctuation)
f (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
< (Token.Operator)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
swap (Token.Name)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
c (Token.Name)
, (Token.Punctuation)
m (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
m (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
c (Token.Name)
= (Token.Operator)
a (Token.Name)
% (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
c (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
        (Token.Text.Whitespace)
f (Token.Name)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
m (Token.Name)
- (Token.Operator)
- (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
else (Token.Keyword)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
a (Token.Name)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
c (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
d (Token.Name)
* (Token.Operator)
e (Token.Name)
/ (Token.Operator)
f (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
gcm (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
d (Token.Name)
= (Token.Operator)
a (Token.Name)
, (Token.Punctuation)
e (Token.Name)
= (Token.Operator)
b (Token.Name)
, (Token.Punctuation)
f (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
< (Token.Operator)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
swap (Token.Name)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
c (Token.Name)
, (Token.Punctuation)
m (Token.Name)
= (Token.Operator)
1 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
while (Token.Keyword)
( (Token.Punctuation)
m (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
c (Token.Name)
= (Token.Operator)
a (Token.Name)
% (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
c (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
        (Token.Text.Whitespace)
f (Token.Name)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
m (Token.Name)
- (Token.Operator)
- (Token.Operator)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
else (Token.Keyword)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
a (Token.Name)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
c (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
f (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
prime (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
< (Token.Operator)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
      (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
else (Token.Keyword)
  (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
= (Token.Operator)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
      (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
else (Token.Keyword)
  (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
% (Token.Operator)
2 (Token.Literal.Number.Integer)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
      (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
double (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
sqrt (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
for (Token.Keyword)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
i (Token.Name)
= (Token.Operator)
3 (Token.Literal.Number.Integer)
; (Token.Punctuation)
i (Token.Name)
< (Token.Operator)
= (Token.Operator)
b (Token.Name)
; (Token.Punctuation)
i (Token.Name)
+ (Token.Operator)
= (Token.Operator)
2 (Token.Literal.Number.Integer)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
% (Token.Operator)
i (Token.Name)
= (Token.Operator)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
         (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
false (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
    (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
true (Token.Name.Builtin)
; (Token.Punctuation)

 (Token.Text.Whitespace)
  (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
struct (Token.Keyword)
  (Token.Text.Whitespace)
Union (Token.Name.Class)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
  (Token.Text.Whitespace)
par (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
Union (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
n (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
par (Token.Name)
= (Token.Operator)
  (Token.Text.Whitespace)
vector (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
( (Token.Punctuation)
n (Token.Name)
, (Token.Punctuation)
  (Token.Text.Whitespace)
-1 (Token.Literal.Number.Integer)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
find (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
x (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
par (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
< (Token.Operator)
0 (Token.Literal.Number.Integer)
) (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
x (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
else (Token.Keyword)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
par (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
par (Token.Name)
[ (Token.Punctuation)
x (Token.Name)
] (Token.Punctuation)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
bool (Token.Keyword.Type)
  (Token.Text.Whitespace)
same (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
find (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
= (Token.Operator)
= (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
Size (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
- (Token.Operator)
par (Token.Name)
[ (Token.Punctuation)
find (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
] (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
void (Token.Keyword.Type)
  (Token.Text.Whitespace)
unite (Token.Name)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
, (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
b (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
a (Token.Name)
= (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
find (Token.Name)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
a (Token.Name)
= (Token.Operator)
= (Token.Operator)
b (Token.Name)
) (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
return (Token.Keyword)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
if (Token.Keyword)
( (Token.Punctuation)
Size (Token.Name)
( (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
> (Token.Operator)
Size (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)

 (Token.Text.Whitespace)
       (Token.Text.Whitespace)
swap (Token.Name)
< (Token.Operator)
int (Token.Keyword.Type)
> (Token.Operator)
( (Token.Punctuation)
a (Token.Name)
, (Token.Punctuation)
b (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
par (Token.Name)
[ (Token.Punctuation)
a (Token.Name)
] (Token.Punctuation)
+ (Token.Operator)
= (Token.Operator)
par (Token.Name)
[ (Token.Punctuation)
b (Token.Name)
] (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
par (Token.Name)
[ (Token.Punctuation)
b (Token.Name)
] (Token.Punctuation)
= (Token.Operator)
a (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
ketas (Token.Name.Function)
( (Token.Punctuation)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
string (Token.Name)
  (Token.Text.Whitespace)
b (Token.Name)
= (Token.Operator)
to_string (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
c (Token.Name)
= (Token.Operator)
0 (Token.Literal.Number.Integer)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
fo (Token.Name)
( (Token.Punctuation)
i (Token.Name)
, (Token.Punctuation)
keta (Token.Name)
( (Token.Punctuation)
a (Token.Name)
) (Token.Punctuation)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
     (Token.Text.Whitespace)
c (Token.Name)
+ (Token.Operator)
= (Token.Operator)
b (Token.Name)
[ (Token.Punctuation)
i (Token.Name)
] (Token.Punctuation)
- (Token.Operator)
' (Token.Literal.String.Char)
0 (Token.Literal.String.Char)
' (Token.Literal.String.Char)
; (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
   (Token.Text.Whitespace)
return (Token.Keyword)
  (Token.Text.Whitespace)
c (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
/*struct aa{
	vector<int> gt;
  aa(int n){
	gt= vector<int>(n, 1);
  }
	void c(V<int> d,int b){
	if(d[b]==0){
		gt[d[b]-1]++;
		gt[gt.sz-1]++;
	}
	else{
		gt[d[b]-1]++;
		c(d,d[d[b]]-1);
	}
}
void cok(int a){
	cout<<gt[a-1]<<endl;
	fo(i,a-1)
	cout<<gt[i]<<endl;
}
};
*/ (Token.Comment.Multiline)

 (Token.Text.Whitespace)
signed (Token.Keyword.Type)
  (Token.Text.Whitespace)
main (Token.Name.Function)
( (Token.Punctuation)
) (Token.Punctuation)
{ (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
int (Token.Keyword.Type)
  (Token.Text.Whitespace)
a (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cin (Token.Name)
> (Token.Operator)
> (Token.Operator)
a (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
	 (Token.Text.Whitespace)
cout (Token.Name)
< (Token.Operator)
< (Token.Operator)
1110 (Token.Literal.Number.Integer)
- (Token.Operator)
a (Token.Name)
< (Token.Operator)
< (Token.Operator)
endl (Token.Name)
; (Token.Punctuation)

 (Token.Text.Whitespace)
} (Token.Punctuation)

 (Token.Text.Whitespace)
