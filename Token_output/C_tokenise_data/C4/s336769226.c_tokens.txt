ID: include
ID: stdio
ID: h
NEWLINE: 

ID: include
ID: stdlib
ID: h
NEWLINE: 

ID: include
ID: string
ID: h
NEWLINE: 

ID: include
ID: math
ID: h
NEWLINE: 

ID: define
ID: loop
LPAREN: (
ID: i
ID: l
ID: r
RPAREN: )
ID: for
LPAREN: (
ID: i
ID: l
SEMI: ;
ID: i
ID: r
SEMI: ;
ID: i
PLUS: +
PLUS: +
RPAREN: )
COMMENT: /*Instead of function, (for).*/
NEWLINE: 

ID: define
ID: rep
LPAREN: (
ID: i
ID: r
RPAREN: )
ID: for
LPAREN: (
ID: i
NUMBER: 0
SEMI: ;
ID: i
ID: r
SEMI: ;
ID: i
PLUS: +
PLUS: +
RPAREN: )
NEWLINE: 

ID: define
ID: Max
LPAREN: (
ID: a
ID: b
RPAREN: )
LPAREN: (
LPAREN: (
ID: a
RPAREN: )
LPAREN: (
ID: b
RPAREN: )
LPAREN: (
ID: a
RPAREN: )
LPAREN: (
ID: b
RPAREN: )
RPAREN: )
NEWLINE: 

ID: define
ID: Min
LPAREN: (
ID: a
ID: b
RPAREN: )
LPAREN: (
LPAREN: (
ID: a
RPAREN: )
LPAREN: (
ID: b
RPAREN: )
LPAREN: (
ID: a
RPAREN: )
LPAREN: (
ID: b
RPAREN: )
RPAREN: )
NEWLINE: 

ID: typedef
ID: long
ID: long
ID: int
ID: lli
SEMI: ;
NEWLINE: 

COMMENT: /*Return Combination ,(nCr)*/
NEWLINE: 

ID: int
ID: combi
LPAREN: (
ID: int
ID: n
ID: int
ID: r
RPAREN: )
NEWLINE: 

LBRACE: {
NEWLINE: 

ID: if
LPAREN: (
ID: r
NUMBER: 0
ID: r
ID: n
RPAREN: )
ID: return
NUMBER: 1
SEMI: ;
NEWLINE: 

ID: else
ID: return
ID: combi
LPAREN: (
ID: n
MINUS: -
NUMBER: 1
ID: r
RPAREN: )
PLUS: +
ID: combi
LPAREN: (
ID: n
MINUS: -
NUMBER: 1
ID: r
MINUS: -
NUMBER: 1
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

COMMENT: /*Return gcd(a, b)*/
NEWLINE: 

ID: int
ID: gcd
LPAREN: (
ID: int
ID: a
ID: int
ID: b
RPAREN: )
LBRACE: {
NEWLINE: 

ID: if
LPAREN: (
ID: b
NUMBER: 0
RPAREN: )
ID: return
ID: a
SEMI: ;
NEWLINE: 

ID: else
ID: return
ID: gcd
LPAREN: (
ID: b
ID: a
ID: b
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

COMMENT: //qsort�֐��Ɏg��compare�֐�,(long long int, int, double�^)
NEWLINE: 

ID: int
ID: compare_lli
LPAREN: (
ID: const
ID: void
TIMES: *
ID: a
ID: const
ID: void
TIMES: *
ID: b
RPAREN: )
NEWLINE: 

LBRACE: {
NEWLINE: 

ID: return
TIMES: *
LPAREN: (
ID: lli
TIMES: *
RPAREN: )
ID: a
MINUS: -
TIMES: *
LPAREN: (
ID: lli
TIMES: *
RPAREN: )
ID: b
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

ID: int
ID: compare_int
LPAREN: (
ID: const
ID: void
TIMES: *
ID: a
ID: const
ID: void
TIMES: *
ID: b
RPAREN: )
NEWLINE: 

LBRACE: {
NEWLINE: 

ID: return
TIMES: *
LPAREN: (
ID: int
TIMES: *
RPAREN: )
ID: a
MINUS: -
TIMES: *
LPAREN: (
ID: int
TIMES: *
RPAREN: )
ID: b
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

ID: int
ID: compare_double
LPAREN: (
ID: const
ID: void
TIMES: *
ID: a
ID: const
ID: void
TIMES: *
ID: b
RPAREN: )
NEWLINE: 

LBRACE: {
NEWLINE: 

ID: return
TIMES: *
LPAREN: (
ID: double
TIMES: *
RPAREN: )
ID: a
MINUS: -
TIMES: *
LPAREN: (
ID: double
TIMES: *
RPAREN: )
ID: b
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

COMMENT: /*qsort(data, 10, sizeof(int_lli_double), compare_int);*/
NEWLINE: 

COMMENT: /*qsort(�z��, �v�f��, sizeof(�z��̌^), compare_�z��̌^);*/
NEWLINE: 

ID: int
ID: main
LPAREN: (
ID: void
RPAREN: )
NEWLINE: 

LBRACE: {
NEWLINE: 

ID: lli
ID: n
ID: i
ID: j
ID: max
NUMBER: 0
SEMI: ;
NEWLINE: 

ID: scanf
LPAREN: (
STRING: "%lld"
ID: n
RPAREN: )
SEMI: ;
NEWLINE: 

ID: lli
ID: a
ID: n
ID: b
ID: n
SEMI: ;
NEWLINE: 

ID: rep
LPAREN: (
ID: i
ID: n
RPAREN: )
ID: scanf
LPAREN: (
STRING: "%lld"
ID: a
ID: i
RPAREN: )
SEMI: ;
NEWLINE: 

ID: memcpy
LPAREN: (
ID: b
ID: a
ID: sizeof
LPAREN: (
ID: a
RPAREN: )
RPAREN: )
SEMI: ;
NEWLINE: 

ID: qsort
LPAREN: (
ID: a
ID: n
ID: sizeof
LPAREN: (
ID: lli
RPAREN: )
ID: compare_lli
RPAREN: )
SEMI: ;
NEWLINE: 

ID: rep
LPAREN: (
ID: i
ID: n
RPAREN: )
LBRACE: {
NEWLINE: 

ID: j
ID: n
MINUS: -
NUMBER: 1
SEMI: ;
NEWLINE: 

ID: if
LPAREN: (
ID: a
ID: j
ID: b
ID: i
RPAREN: )
ID: j
MINUS: -
MINUS: -
SEMI: ;
NEWLINE: 

ID: printf
LPAREN: (
STRING: "%lld\n"
ID: a
ID: j
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

ID: return
NUMBER: 0
SEMI: ;
NEWLINE: 

RBRACE: }
