DIVIDE: /
TIMES: *
ID: ex9_1
NEWLINE: 

ID: suzuto
TIMES: *
DIVIDE: /
NEWLINE: 


ID: include
ID: stdio
ID: h
NEWLINE: 

ID: include
ID: stdlib
ID: h
NEWLINE: 

ID: define
ID: SIZE
NUMBER: 10
NEWLINE: 


ID: typedef
ID: struct
ID: stack
LBRACE: {
COMMENT: /*入力した文字をスタックとして重ねていくための構造体を作る*/
NEWLINE: 

ID: int
ID: size
SEMI: ;
NEWLINE: 

ID: int
ID: count
SEMI: ;
NEWLINE: 

ID: char
ID: inp_str
ID: SIZE
SEMI: ;
NEWLINE: 

ID: char
TIMES: *
ID: top
SEMI: ;
NEWLINE: 

RBRACE: }
ID: stack
SEMI: ;
NEWLINE: 


COMMENT: /*プロトタイプ宣言*/
NEWLINE: 

ID: void
ID: initialize_stack
LPAREN: (
ID: stack
TIMES: *
ID: stack_ptr
RPAREN: )
SEMI: ;
NEWLINE: 

ID: void
ID: push
LPAREN: (
ID: stack
TIMES: *
ID: stack_ptr
ID: char
ID: add_elem
RPAREN: )
SEMI: ;
NEWLINE: 

ID: char
ID: pop
LPAREN: (
ID: stack
TIMES: *
ID: stack_ptr
RPAREN: )
SEMI: ;
NEWLINE: 


ID: int
ID: main
LPAREN: (
ID: void
RPAREN: )
LBRACE: {
NEWLINE: 

ID: stack
ID: inp_stack
ID: res_stack
SEMI: ;
COMMENT: /*変数の宣言*/
NEWLINE: 

ID: char
ID: inp
ID: SIZE
PLUS: +
NUMBER: 1
ID: ins
SEMI: ;
NEWLINE: 

ID: int
ID: i
SEMI: ;
NEWLINE: 


ID: initialize_stack
LPAREN: (
ID: inp_stack
RPAREN: )
SEMI: ;
COMMENT: /*inp_stackを初期化*/
NEWLINE: 

ID: initialize_stack
LPAREN: (
ID: res_stack
RPAREN: )
SEMI: ;
COMMENT: /*res_stackを初期化*/
NEWLINE: 


ID: scanf
LPAREN: (
STRING: "%s"
ID: inp
RPAREN: )
SEMI: ;
COMMENT: /*入力内容を記憶*/
NEWLINE: 


ID: for
LPAREN: (
ID: i
NUMBER: 0
SEMI: ;
ID: i
ID: SIZE
PLUS: +
NUMBER: 1
SEMI: ;
ID: i
PLUS: +
PLUS: +
RPAREN: )
LBRACE: {
NEWLINE: 

ID: ins
ID: inp
ID: i
SEMI: ;
COMMENT: /*i + 1番目の入力取り出し*/
NEWLINE: 

ID: if
LPAREN: (
ID: ins
NUMBER: 0
RPAREN: )
LBRACE: {
COMMENT: /*末尾の識別*/
NEWLINE: 

ID: break
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

ID: if
LPAREN: (
ID: ins
ID: B
RPAREN: )
LBRACE: {
COMMENT: /*バックスペースの時、スタックから一番上=最後に入力した文字を取り出す*/
NEWLINE: 

ID: pop
LPAREN: (
ID: inp_stack
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

ID: else
LBRACE: {
NEWLINE: 

ID: push
LPAREN: (
ID: inp_stack
ID: ins
RPAREN: )
SEMI: ;
COMMENT: /*文字入力の時、スタックの一番上に追加*/
NEWLINE: 

RBRACE: }
NEWLINE: 

RBRACE: }
NEWLINE: 


ID: while
LPAREN: (
ID: inp_stack
ID: count
NUMBER: 0
RPAREN: )
LBRACE: {
COMMENT: /*inp_stackの中身を全て(逆順に)res_stackに移し替える*/
NEWLINE: 

ID: push
LPAREN: (
ID: res_stack
ID: pop
LPAREN: (
ID: inp_stack
RPAREN: )
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 


ID: while
LPAREN: (
ID: res_stack
ID: count
NUMBER: 0
RPAREN: )
LBRACE: {
COMMENT: /*res_stackの中身を上から順に取り出していって答えを出力*/
NEWLINE: 

ID: putchar
LPAREN: (
ID: pop
LPAREN: (
ID: res_stack
RPAREN: )
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

ID: printf
LPAREN: (
STRING: "\n"
RPAREN: )
SEMI: ;
COMMENT: /*改行*/
NEWLINE: 

ID: return
NUMBER: 0
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 


ID: void
ID: initialize_stack
LPAREN: (
ID: stack
TIMES: *
ID: stack_ptr
RPAREN: )
LBRACE: {
COMMENT: /*スタックを初期化する関数*/
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: count
NUMBER: 0
SEMI: ;
COMMENT: /*要素の数 = 0*/
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: size
ID: SIZE
SEMI: ;
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: top
LPAREN: (
ID: stack_ptr
MINUS: -
ID: inp_str
ID: SIZE
RPAREN: )
SEMI: ;
COMMENT: /*スタックの底に頂点を合わせる*/
NEWLINE: 

RBRACE: }
NEWLINE: 


ID: void
ID: push
LPAREN: (
ID: stack
TIMES: *
ID: stack_ptr
ID: char
ID: add_elem
RPAREN: )
LBRACE: {
COMMENT: /*スタックに要素を追加する関数*/
NEWLINE: 

ID: if
LPAREN: (
ID: stack_ptr
MINUS: -
ID: count
ID: stack_ptr
MINUS: -
ID: size
RPAREN: )
LBRACE: {
COMMENT: /*スタックをあふれた時のエラー出力*/
NEWLINE: 

ID: fprintf
LPAREN: (
ID: stderr
STRING: "Error: stack overflow.\n"
RPAREN: )
SEMI: ;
NEWLINE: 

ID: exit
LPAREN: (
NUMBER: 1
RPAREN: )
SEMI: ;
NEWLINE: 

RBRACE: }
ID: else
LBRACE: {
COMMENT: /*頂点の位置を1つ上げて、その位置に要素を積む*/
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: top
MINUS: -
MINUS: -
SEMI: ;
NEWLINE: 

TIMES: *
LPAREN: (
ID: stack_ptr
MINUS: -
ID: top
RPAREN: )
ID: add_elem
SEMI: ;
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: count
PLUS: +
PLUS: +
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

RBRACE: }
NEWLINE: 


ID: char
ID: pop
LPAREN: (
ID: stack
TIMES: *
ID: stack_ptr
RPAREN: )
LBRACE: {
NEWLINE: 

ID: char
ID: output_elem
SEMI: ;
NEWLINE: 

ID: if
LPAREN: (
ID: stack_ptr
MINUS: -
ID: count
NUMBER: 0
RPAREN: )
LBRACE: {
COMMENT: /*スタックの底が尽きている時には何も取り出さない*/
NEWLINE: 

ID: return
ID: B
SEMI: ;
COMMENT: /*意味のない仮の出力*/
NEWLINE: 

RBRACE: }
ID: else
LBRACE: {
COMMENT: /*一番上の要素を取り出し、頂点を一個下げる*/
NEWLINE: 

ID: output_elem
TIMES: *
LPAREN: (
ID: stack_ptr
MINUS: -
ID: top
RPAREN: )
SEMI: ;
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: count
MINUS: -
MINUS: -
SEMI: ;
NEWLINE: 

ID: stack_ptr
MINUS: -
ID: top
PLUS: +
PLUS: +
SEMI: ;
NEWLINE: 

ID: return
ID: output_elem
SEMI: ;
NEWLINE: 

RBRACE: }
NEWLINE: 

RBRACE: }
NEWLINE: 

