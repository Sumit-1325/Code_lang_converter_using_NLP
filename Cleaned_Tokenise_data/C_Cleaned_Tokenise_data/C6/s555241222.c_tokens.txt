COMMENT: //set many funcs template NEWLINE: COMMENT: //Ver.20180717 NEWLINE: ID: include ID: stdio ID: h NEWLINE: ID: include ID: string ID: h NEWLINE: ID: include ID: stdlib ID: h NEWLINE: ID: include ID: stdbool ID: h NEWLINE: ID: include ID: time ID: h NEWLINE: ID: define ID: inf NUMBER: 1072114514 NEWLINE: ID: define ID: llinf NUMBER: 4154118101919364364 NEWLINE: ID: define ID: mod NUMBER: 1000000007 NEWLINE: ID: define ID: pi NUMBER: 3 NUMBER: 1415926535897932384 NEWLINE: ID: int ID: max LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b RPAREN: ) LBRACE: { ID: return ID: a SEMI: ; RBRACE: } ID: return ID: b SEMI: ; RBRACE: } NEWLINE: ID: int ID: min LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b RPAREN: ) LBRACE: { ID: return ID: a SEMI: ; RBRACE: } ID: return ID: b SEMI: ; RBRACE: } NEWLINE: ID: int ID: zt LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: return ID: max LPAREN: ( ID: a ID: b RPAREN: ) MINUS: - ID: min LPAREN: ( ID: a ID: b RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: int ID: round LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( LPAREN: ( ID: a ID: b RPAREN: ) TIMES: * NUMBER: 2 ID: b RPAREN: ) LBRACE: { ID: return LPAREN: ( ID: a DIVIDE: / ID: b RPAREN: ) PLUS: + NUMBER: 1 SEMI: ; RBRACE: } ID: return ID: a DIVIDE: / ID: b SEMI: ; RBRACE: } NEWLINE: ID: int ID: ceil LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b NUMBER: 0 RPAREN: ) LBRACE: { ID: return ID: a DIVIDE: / ID: b SEMI: ; RBRACE: } ID: return LPAREN: ( ID: a DIVIDE: / ID: b RPAREN: ) PLUS: + NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: gcd LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: int ID: c SEMI: ; ID: while LPAREN: ( ID: b NUMBER: 0 RPAREN: ) LBRACE: { ID: c ID: a ID: b SEMI: ; ID: a ID: b SEMI: ; ID: b ID: c SEMI: ; RBRACE: } ID: return ID: a SEMI: ; RBRACE: } NEWLINE: ID: int ID: lcm LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: int ID: c ID: gcd LPAREN: ( ID: a ID: b RPAREN: ) SEMI: ; ID: a DIVIDE: / ID: c SEMI: ; ID: return ID: a TIMES: * ID: b SEMI: ; RBRACE: } NEWLINE: ID: int ID: nCr LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: int ID: i ID: r NUMBER: 1 SEMI: ; ID: for LPAREN: ( ID: i NUMBER: 1 SEMI: ; ID: i ID: b SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { ID: r TIMES: * LPAREN: ( ID: a PLUS: + NUMBER: 1 MINUS: - ID: i RPAREN: ) SEMI: ; ID: r DIVIDE: / ID: i SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: int ID: nHr LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: return ID: nCr LPAREN: ( ID: a PLUS: + ID: b MINUS: - NUMBER: 1 ID: b RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: int ID: fact LPAREN: ( ID: int ID: a RPAREN: ) LBRACE: { ID: int ID: i ID: r NUMBER: 1 SEMI: ; ID: for LPAREN: ( ID: i NUMBER: 1 SEMI: ; ID: i ID: a SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { ID: r TIMES: * ID: i SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: int ID: pow LPAREN: ( ID: int ID: a ID: int ID: b RPAREN: ) LBRACE: { ID: int ID: i ID: r NUMBER: 1 SEMI: ; ID: for LPAREN: ( ID: i NUMBER: 1 SEMI: ; ID: i ID: b SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { ID: r TIMES: * ID: a SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: int ID: dsum LPAREN: ( ID: int ID: x RPAREN: ) LBRACE: { ID: int ID: r NUMBER: 0 SEMI: ; ID: while LPAREN: ( ID: x RPAREN: ) LBRACE: { ID: r PLUS: + LPAREN: ( ID: x NUMBER: 10 RPAREN: ) SEMI: ; ID: x DIVIDE: / NUMBER: 10 SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: int ID: dsumb LPAREN: ( ID: int ID: x ID: int ID: b RPAREN: ) LBRACE: { ID: int ID: r NUMBER: 0 SEMI: ; ID: while LPAREN: ( ID: x RPAREN: ) LBRACE: { ID: r PLUS: + LPAREN: ( ID: x ID: b RPAREN: ) SEMI: ; ID: x DIVIDE: / ID: b SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: int ID: sankaku LPAREN: ( ID: int ID: x RPAREN: ) LBRACE: { ID: return LPAREN: ( LPAREN: ( NUMBER: 1 PLUS: + ID: x RPAREN: ) TIMES: * ID: x RPAREN: ) DIVIDE: / NUMBER: 2 SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llmax LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b RPAREN: ) LBRACE: { ID: return ID: a SEMI: ; RBRACE: } ID: return ID: b SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llmin LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b RPAREN: ) LBRACE: { ID: return ID: a SEMI: ; RBRACE: } ID: return ID: b SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llzt LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: return ID: llmax LPAREN: ( ID: a ID: b RPAREN: ) MINUS: - ID: llmin LPAREN: ( ID: a ID: b RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llround LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( LPAREN: ( ID: a ID: b RPAREN: ) TIMES: * NUMBER: 2 ID: b RPAREN: ) LBRACE: { ID: return LPAREN: ( ID: a DIVIDE: / ID: b RPAREN: ) PLUS: + NUMBER: 1 SEMI: ; RBRACE: } ID: return ID: a DIVIDE: / ID: b SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llceil LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b NUMBER: 0 RPAREN: ) LBRACE: { ID: return ID: a DIVIDE: / ID: b SEMI: ; RBRACE: } ID: return LPAREN: ( ID: a DIVIDE: / ID: b RPAREN: ) PLUS: + NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llgcd LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: long ID: long ID: c SEMI: ; ID: while LPAREN: ( ID: b NUMBER: 0 RPAREN: ) LBRACE: { ID: c ID: a ID: b SEMI: ; ID: a ID: b SEMI: ; ID: b ID: c SEMI: ; RBRACE: } ID: return ID: a SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: lllcm LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: long ID: long ID: c ID: llgcd LPAREN: ( ID: a ID: b RPAREN: ) SEMI: ; ID: a DIVIDE: / ID: c SEMI: ; ID: return ID: a TIMES: * ID: b SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llnCr LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: long ID: long ID: i ID: r NUMBER: 1 SEMI: ; ID: for LPAREN: ( ID: i NUMBER: 1 SEMI: ; ID: i ID: b SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { ID: r TIMES: * LPAREN: ( ID: a PLUS: + NUMBER: 1 MINUS: - ID: i RPAREN: ) SEMI: ; ID: r DIVIDE: / ID: i SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llnHr LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: return ID: llnCr LPAREN: ( ID: a PLUS: + ID: b MINUS: - NUMBER: 1 ID: b RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llfact LPAREN: ( ID: long ID: long ID: a RPAREN: ) LBRACE: { ID: long ID: long ID: i ID: r NUMBER: 1 SEMI: ; ID: for LPAREN: ( ID: i NUMBER: 1 SEMI: ; ID: i ID: a SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { ID: r TIMES: * ID: i SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llpow LPAREN: ( ID: long ID: long ID: a ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: long ID: long ID: i ID: r NUMBER: 1 SEMI: ; ID: for LPAREN: ( ID: i NUMBER: 1 SEMI: ; ID: i ID: b SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { ID: r TIMES: * ID: a SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: lldsum LPAREN: ( ID: long ID: long ID: x RPAREN: ) LBRACE: { ID: long ID: long ID: r NUMBER: 0 SEMI: ; ID: while LPAREN: ( ID: x RPAREN: ) LBRACE: { ID: r PLUS: + LPAREN: ( ID: x NUMBER: 10 RPAREN: ) SEMI: ; ID: x DIVIDE: / NUMBER: 10 SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: lldsumb LPAREN: ( ID: long ID: long ID: x ID: long ID: long ID: b RPAREN: ) LBRACE: { ID: long ID: long ID: r NUMBER: 0 SEMI: ; ID: while LPAREN: ( ID: x RPAREN: ) LBRACE: { ID: r PLUS: + LPAREN: ( ID: x ID: b RPAREN: ) SEMI: ; ID: x DIVIDE: / ID: b SEMI: ; RBRACE: } ID: return ID: r SEMI: ; RBRACE: } NEWLINE: ID: long ID: long ID: llsankaku LPAREN: ( ID: long ID: long ID: x RPAREN: ) LBRACE: { ID: return LPAREN: ( LPAREN: ( NUMBER: 1 PLUS: + ID: x RPAREN: ) TIMES: * ID: x RPAREN: ) DIVIDE: / NUMBER: 2 SEMI: ; RBRACE: } NEWLINE: ID: double ID: dbmax LPAREN: ( ID: double ID: a ID: double ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b RPAREN: ) LBRACE: { ID: return ID: a SEMI: ; RBRACE: } ID: return ID: b SEMI: ; RBRACE: } NEWLINE: ID: double ID: dbmin LPAREN: ( ID: double ID: a ID: double ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( ID: a ID: b RPAREN: ) LBRACE: { ID: return ID: a SEMI: ; RBRACE: } ID: return ID: b SEMI: ; RBRACE: } NEWLINE: ID: double ID: dbzt LPAREN: ( ID: double ID: a ID: double ID: b RPAREN: ) LBRACE: { ID: return ID: dbmax LPAREN: ( ID: a ID: b RPAREN: ) MINUS: - ID: dbmin LPAREN: ( ID: a ID: b RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: int ID: sortfncsj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } ID: if LPAREN: ( TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 0 SEMI: ; RBRACE: } ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: sortfnckj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } ID: if LPAREN: ( TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: int TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 0 SEMI: ; RBRACE: } ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: llsortfncsj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } ID: if LPAREN: ( TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 0 SEMI: ; RBRACE: } ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: llsortfnckj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } ID: if LPAREN: ( TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: long ID: long TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 0 SEMI: ; RBRACE: } ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: dbsortfncsj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } ID: if LPAREN: ( TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 0 SEMI: ; RBRACE: } ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: dbsortfnckj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: if LPAREN: ( TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } ID: if LPAREN: ( TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: a TIMES: * LPAREN: ( ID: double TIMES: * RPAREN: ) ID: b RPAREN: ) LBRACE: { ID: return NUMBER: 0 SEMI: ; RBRACE: } ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: int ID: strsortfncsj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: return ID: strcmp LPAREN: ( LPAREN: ( ID: char TIMES: * RPAREN: ) ID: a LPAREN: ( ID: char TIMES: * RPAREN: ) ID: b RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: int ID: strsortfnckj LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { ID: return ID: strcmp LPAREN: ( LPAREN: ( ID: char TIMES: * RPAREN: ) ID: b LPAREN: ( ID: char TIMES: * RPAREN: ) ID: a RPAREN: ) SEMI: ; RBRACE: } NEWLINE: ID: void ID: shuffledget LPAREN: ( ID: int ID: x ID: int ID: n RPAREN: ) LBRACE: { NEWLINE: ID: srand LPAREN: ( ID: time LPAREN: ( NUMBER: 0 RPAREN: ) RPAREN: ) SEMI: ; NEWLINE: ID: int ID: i ID: b NUMBER: 524288 ID: p ID: c SEMI: ; NEWLINE: ID: for LPAREN: ( ID: i NUMBER: 0 SEMI: ; ID: i ID: n SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { NEWLINE: ID: b ID: i ID: i SEMI: ; NEWLINE: RBRACE: } NEWLINE: ID: for LPAREN: ( ID: i ID: n SEMI: ; ID: i NUMBER: 1 SEMI: ; ID: i MINUS: - MINUS: - RPAREN: ) LBRACE: { NEWLINE: ID: p ID: rand LPAREN: ( RPAREN: ) ID: i SEMI: ; NEWLINE: ID: c ID: b ID: i MINUS: - NUMBER: 1 SEMI: ; ID: b ID: i MINUS: - NUMBER: 1 ID: b ID: p SEMI: ; ID: b ID: p ID: c SEMI: ; NEWLINE: RBRACE: } NEWLINE: ID: for LPAREN: ( ID: i NUMBER: 0 SEMI: ; ID: i ID: n SEMI: ; ID: i PLUS: + PLUS: + RPAREN: ) LBRACE: { NEWLINE: ID: scanf LPAREN: ( STRING: "%d" ID: x ID: b ID: i RPAREN: ) SEMI: ; NEWLINE: RBRACE: } NEWLINE: RBRACE: } NEWLINE: ID: int ID: dx4 NUMBER: 4 LBRACE: { NUMBER: 1 MINUS: - NUMBER: 1 NUMBER: 0 NUMBER: 0 RBRACE: } SEMI: ; NEWLINE: ID: int ID: dy4 NUMBER: 4 LBRACE: { NUMBER: 0 NUMBER: 0 NUMBER: 1 MINUS: - NUMBER: 1 RBRACE: } SEMI: ; NEWLINE: ID: int ID: dx8 NUMBER: 8 LBRACE: { MINUS: - NUMBER: 1 MINUS: - NUMBER: 1 MINUS: - NUMBER: 1 NUMBER: 0 NUMBER: 0 NUMBER: 1 NUMBER: 1 NUMBER: 1 RBRACE: } SEMI: ; NEWLINE: ID: int ID: dy8 NUMBER: 8 LBRACE: { MINUS: - NUMBER: 1 NUMBER: 0 NUMBER: 1 MINUS: - NUMBER: 1 NUMBER: 1 MINUS: - NUMBER: 1 NUMBER: 0 NUMBER: 1 RBRACE: } SEMI: ; NEWLINE: ID: int ID: search LPAREN: ( ID: int ID: x ID: int ID: a ID: int ID: n RPAREN: ) LBRACE: { NEWLINE: ID: int ID: st NUMBER: 0 ID: fi ID: n MINUS: - NUMBER: 1 ID: te SEMI: ; NEWLINE: ID: while LPAREN: ( ID: st ID: fi RPAREN: ) LBRACE: { NEWLINE: ID: te LPAREN: ( ID: st PLUS: + ID: fi RPAREN: ) DIVIDE: / NUMBER: 2 SEMI: ; NEWLINE: ID: if LPAREN: ( ID: a ID: te ID: x RPAREN: ) LBRACE: { ID: st ID: te PLUS: + NUMBER: 1 SEMI: ; RBRACE: } ID: else LBRACE: { ID: fi ID: te MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: RBRACE: } NEWLINE: ID: return ID: st SEMI: ; NEWLINE: RBRACE: } NEWLINE: ID: typedef ID: struct LBRACE: { NEWLINE: ID: int ID: val SEMI: ; NEWLINE: ID: int ID: node SEMI: ; NEWLINE: RBRACE: } ID: sd SEMI: ; NEWLINE: ID: int ID: sdsortfnc LPAREN: ( ID: const ID: void TIMES: * ID: a ID: const ID: void TIMES: * ID: b RPAREN: ) LBRACE: { NEWLINE: ID: if LPAREN: ( LPAREN: ( LPAREN: ( ID: sd TIMES: * RPAREN: ) ID: a RPAREN: ) MINUS: - ID: val LPAREN: ( LPAREN: ( ID: sd TIMES: * RPAREN: ) ID: b RPAREN: ) MINUS: - ID: val RPAREN: ) LBRACE: { ID: return MINUS: - NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: if LPAREN: ( LPAREN: ( LPAREN: ( ID: sd TIMES: * RPAREN: ) ID: a RPAREN: ) MINUS: - ID: val LPAREN: ( LPAREN: ( ID: sd TIMES: * RPAREN: ) ID: b RPAREN: ) MINUS: - ID: val RPAREN: ) LBRACE: { ID: return NUMBER: 1 SEMI: ; RBRACE: } NEWLINE: ID: return NUMBER: 0 SEMI: ; NEWLINE: RBRACE: } NEWLINE: ID: int ID: main LPAREN: ( ID: void RPAREN: ) LBRACE: { NEWLINE: ID: int ID: i ID: j ID: n ID: m ID: k ID: a NUMBER: 524288 ID: b ID: c ID: h ID: w ID: r NUMBER: 0 ID: l ID: t SEMI: ; NEWLINE: ID: double ID: d SEMI: ; NEWLINE: ID: char ID: s NUMBER: 524288 SEMI: ; NEWLINE: ID: scanf LPAREN: ( STRING: "%d" ID: n RPAREN: ) SEMI: ; NEWLINE: ID: printf LPAREN: ( STRING: "%d\n" NUMBER: 1110 MINUS: - ID: n RPAREN: ) SEMI: ; NEWLINE: ID: return NUMBER: 0 SEMI: ; NEWLINE: RBRACE: }